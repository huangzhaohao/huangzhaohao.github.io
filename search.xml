<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[测试1111]]></title>
    <url>%2F2021%2F05%2F21%2F21_05_21_test%2F</url>
    <content type="text"><![CDATA[CMakeLists.txt12# For more information about using CMake with Android Studio, read the测试]]></content>
      <categories>
        <category>测试4444</category>
        <category>测试5555</category>
      </categories>
      <tags>
        <tag>测试2222</tag>
        <tag>测试3333</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针类型_空指针_二级指针_指针运算_指针与数组]]></title>
    <url>%2F2019%2F09%2F27%2F08_01_C_01%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include&lt;Windows.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;//指针为什么要有类型？//指针有类型，地址没有类型//地址只是开始的位置，类型读取到什么位置结束/*void main()&#123; int i = 90; //int 类型的指针 int *p = &amp;i; double j = 89.3; //赋值为double类型变量的地址 p = &amp;j; printf("double size:%d\n", sizeof(double)); printf("%#x,%lf\n", p,*p); getchar();&#125;*///2.NULL空指针/*void main()&#123; int i = 9; int *p = NULL; //p = &amp;i; //空指针的默认值为0 printf("%#x\n", p); //访问内存地址0x000000操作系统不允许 //p = 10000; //操作系统不允许访问 printf("%d\n", *p); getchar();&#125;*///3.多级指针(二级指针)//指针保存的是变量的地址，保存的这个变量还可以是一个指针变量//动态内存分配给二维数组/*void main()&#123; int a = 50; //p1上保存的a的地址 int *p1 = &amp;a; //p2上保存的p1的地址 int **p2 = &amp;p1; printf("p1:%#x,p2:%#x\n", p1, p2); **p2 = 90; printf("%d\n", a); getchar();&#125;*///4.指针的运算//指针的运算，一般在数组遍历时才有意义，基于数组在内存中线性排列的方式/*void main()&#123; //数组在内存中连续存储 int ids[] = &#123;78,90,23,65,19&#125;; //数组变量名：ids就是数组的首地址 printf("%#x\n",ids); printf("%#x\n", &amp;ids); printf("%#x\n", &amp;ids[0]); printf("%#x\n", &amp;ids[1]); //指针变量 int *p = ids; printf("%d\n", *p); //指针的加法 p++; //p++向前移动sizeof(数据类型)个字节 printf("%d\n", *p); getchar();&#125;*///通过指针给数组赋值/*void main()&#123; int uids[5]; //高级写法 //int i = 0; //for (; i &lt; 5; i++)&#123; // uids[i] = i; //&#125; //早些版本的写法 int *p = uids; printf("%#x\n", p); int i = 0; for (; p &lt; uids + 5; p++)&#123; *p = i; i++; &#125; getchar();&#125;*///6.函数指针/*int msg(char* msg,char* title)&#123; MessageBox(0,msg,title,0); return 0;&#125;void main()&#123; //msg(); printf("%#x\n", msg); printf("%#x\n", &amp;msg); //函数指针 //函数返回值类型，函数指针的名称，函数的参数列表 int(*fun_p)(char* msg, char* title) = msg; fun_p("消息内容","标题"); getchar();&#125;*/int add(int a, int b)&#123; return a + b;&#125;int minus(int a,int b)&#123; return a - b;&#125;//msg函数需要传递一个函数指针参数//类似于Java中的回调函数/*void msg(int(*func_p)(int a, int b), int m, int n)&#123; printf("执行一段代码...\n"); printf("执行另外一个函数...\n"); int r = func_p(m,n); printf("执行结果:%d\n", r);&#125;void main()&#123; //加法 //int(*func_p)(int a, int b) = add; msg(add, 10, 20); //减法 //int(*func_p)(int a, int b) = minus; msg(minus, 50, 10); getchar();&#125;*///案列：用随机数生成一个数组，写一个函数查找最小的值，并返回最小值的地址，在主函数中打印出来int* getMinPointer(int ids[], int len)&#123; int i = 0; int* p = &amp;ids[0]; for (; i &lt; len;i++)&#123; if (ids[i] &lt; *p)&#123; p = &amp;ids[i]; &#125; &#125; return p;&#125;void main()&#123; int ids[10]; int i = 0; //初始化随机数发生器，设置种子，种子不一样，随机数才不一样 //当前时间作为种子 有符号 int --xx -&gt; +xx srand((unsigned)time(NULL)); for (; i &lt; 10; i++)&#123; ids[i] = rand() % 100; printf("%d\n", ids[i]); &#125; int* p = getMinPointer(ids, sizeof(ids) / sizeof(int)); printf("%#x,%d\n", p, *p); getchar();&#125;]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_C语言</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态内存分配]]></title>
    <url>%2F2019%2F09%2F27%2F08_03_C_01%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;Windows.h&gt;//动态内存分配/*void main()&#123; //40M //stack overflow错误，栈溢出 //静态内存分配 int a[1024 * 1024 * 10 * sizeof(int)]; //栈内存 //c语言内存分配： //1.栈区(stack) //windows下，栈内存分配2M（确定的常数）,超出了限制，提示stack overflow错误 //自动分配，释放 //2.堆区(heap) //程序员手动分配和释放，操作系统80%内存 //3.全局区或静态区 //4.字符常量区 //5.程序代码区 getchar();&#125;*//*//栈内存void stackFun()&#123; int a[1024]; //栈内存自动释放&#125;//堆内存void heapFun()&#123; //40M内存 //void *任意类型的指针 int* p = malloc(1024 * 1024 * 10 * sizeof(int)); //释放 free(p);&#125;void main()&#123; //在堆内存上，分配40M的内存 while (1)&#123; Sleep(1000); stackFun(); &#125; getchar();&#125;*///创建一个数组，动态指定数组的大小//(在程序运行过程中，可以随意的开辟指定大小的内存以供使用，相当于JAVA中的集合)//静态内存分配，分配内存大小是固定的，问题：1.很容易超出栈内存的最大值 2.为了防止内存不够用会开辟更多的内存，容易浪费内存//动态内存分配，在程序运行过程中，动态指定需要使用的内存大小，手动释放，释放之后这些内存还可以被重新使用/*void main()&#123; //静态内存分配创建数组，数组的大小是固定的 int a[10]; int len; printf("输入数组的长度："); scanf("%d", &amp;len); //开辟内存，内存大小len*4字节 int* p = malloc(len * sizeof(int)); //p,数组的首地址，p就是数组的名称 //给数组元素赋值（使用这一块刚刚开辟出来的内存区域） int i = 0; for (; i &lt; len; i++)&#123; p[i] = rand() % 100; printf("%d,%#x\n", p[i], &amp;p[i]); &#125; //手动释放内存 free(p); getchar();&#125;*///realloc 重新分配内存/*void main()&#123; int len; printf("第一次输入数组的长度："); scanf("%d", &amp;len); //int* p = malloc(len * sizeof(int)); int* p = calloc(len, sizeof(int)); int i = 0; for (; i &lt; len; i++)&#123; p[i] = rand() % 100; printf("%d,%#x\n", p[i], &amp;p[i]); &#125; int addLen; printf("输入数组增加的长度："); scanf("%d", &amp;addLen); //内存不够用，扩大刚刚分配的内存空间 //1.原来内存的指针 2.内存扩大之后的总大小 int* p2 = realloc(p, sizeof(int)* (len + addLen)); if (p2 == NULL)&#123; printf("重新分配失败，能分配的内存不够用了"); &#125; //重新分配内存的两种情况： //缩小，缩小的那一部分数据会丢失 //扩大，（连续的） //1.如果当前内存段后面有需要的内存空间，直接扩展这段内存空间，realloc返回原指针 //2.如果当前内存段后面的空闲字节不够，那么就使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并将原来的数据块释放掉，返回新的内存地址 //3.如果申请失败，返回NULL，原来的指针仍然有效 //重新赋值 i = 0; for (; i &lt; len + addLen;i++)&#123; p2[i] = rand() % 200; printf("%d,%#x\n", p2[i], &amp;p2[i]); &#125; //手动释放内存 if (p2 != NULL)&#123; free(p2); p2 = NULL; &#125; getchar();&#125;*///内存分配的几个注意细节//1.不能多次释放//2.释放完之后，给指针置NULL，标志释放完成//3.内存泄漏(p重新赋值之后，再free,并没有真正释放内存)/*void main()&#123; int len; printf("输入数组的长度："); scanf("%d", &amp;len); int* p = malloc(len * sizeof(int)); int i = 0; for (; i &lt; len; i++)&#123; p[i] = rand() % 100; printf("%d,%#x\n", p[i], &amp;p[i]); &#125; if (p != NULL)&#123; free(p); p = NULL; &#125; getchar();&#125;*/void main()&#123; //40M int* p1 = malloc(1024 * 1024 * 10 * sizeof(int)); free(p1); p1 = NULL; printf("%#x\n", p1); //80M p1 = malloc(1024 * 1024 * 10 * sizeof(int) * 2); free(p1); p1 = NULL; getchar();&#125;]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_C语言</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串]]></title>
    <url>%2F2019%2F09%2F27%2F08_03_C_02%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;Windows.h&gt;//使用字符数组存储字符串/*void main()&#123; //char str[] = &#123; 'c' , 'h' , 'i' , 'n' , 'a' , '\0' &#125;; //char str[6] = &#123; 'c', 'h', 'i', 'n', 'a' &#125;;//多出一个默认为'\0' char str[10] = "china"; //可以修改 str[0] = 's'; printf("%s\n", str); printf("%#x\n", str); getchar();&#125;*///字符指针/*void main()&#123; //内存连续排列 char *str = "how are you?"; //不能修改 //str += 1; //*str = 'y'; //str[0] = 'w'; printf("%s\n", str); printf("%#x\n", str); //使用指针加法，截取字符串 str += 3; while (*str)&#123;//取不到值时*str为0 printf("%c", *str); str++; &#125; getchar();&#125;*///strcat字符串拼接函数//在线API文档：//http://www.kuqin.com/clib/string/strcpy.html/*void main(void)&#123; char dest[50]; char *a = "china"; char *b = " is powerful!"; strcpy(dest, a); strcat(dest, b); printf("%s\n", dest); system("pause");&#125;*///strchr在一个串中查找给定字符的第一个匹配之处/*void main(void)&#123; char *str = "I want go to USA!"; //U元素的指针 //str+3 char* p = strchr(str, 'w'); if (p)&#123; printf("索引位置：%d\n", p - str); &#125; else&#123; printf("没有找到"); &#125; system("pause");&#125;*///strstr 从字符串haystack中寻找needle第一次出现的位置/*void main(void)&#123; char *haystack = "I want go to USA!"; char *needle = "to"; //U元素的指针 char* p = strstr(haystack, needle); if (p)&#123; printf("索引位置：%d\n", p - haystack); &#125; else&#123; printf("没有找到"); &#125; system("pause");&#125;*///strcmp 比较字符串 strcmpi 比较字符串，忽略大小写/*void main(void)&#123; char *str1 = "abc"; char *str2 = "ABC"; //int r = strcmp(str1, str2); int r = _strcmpi(str1, str2); printf("%d\n", r); //str1 &gt; str2 if (r &gt; 0)&#123; printf("str1 大于str2\n"); &#125; else if (r == 0)&#123; printf("str1 等于str2\n"); &#125; //str1 &lt; str2 else if (r &lt; 0)&#123; printf("str1 小于str2\n"); &#125; system("pause");&#125;*///strset 把字符串s中的所有字符都设置成字符c/*void main(void)&#123; char str[] = "internet change the world!"; _strset(str, 'w'); printf("%s\n", str); system("pause");&#125;*///strrev 把字符串s的所有字符的顺序颠倒过来/*void main(void)&#123; char str[] = "internet change the world!"; _strrev(str); printf("%s\n", str); system("pause");&#125;*///atoi 字符串转为int类型//atol()：将字符串转换为长整型值/*void main(void)&#123; char* str = "78"; int r = atoi(str); printf("%d\n", r); system("pause");&#125;*/// 字符串转为double类型/*void main(void)&#123; char* str = "77b8b"; char** p = NULL; //char* p = str + 2; //参数说明：str为要转换的字符串，endstr 为第一个不能转换的字符的指针 double r = strtod(str,p); printf("%lf\n", r); printf("%#x\n", p); system("pause");&#125;*///strupr转换为大写/*void main(void)&#123; char str[] = "CHINA motherland!"; _strupr(str); printf("%s\n", str); system("pause");&#125;*///转换为小写/*void mystrlwr(char str[], int len)&#123; int i = 0; for (; i &lt; len; i++)&#123; //A-Z 字母 a-Z if (str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z')&#123; str[i] = str[i] - 'A' + 'a'; &#125; &#125;&#125;void main(void)&#123; char str[] = "CHINA motherland!"; mystrlwr(str, strlen(str)); printf("%s\n", str); system("pause");&#125;*///练习：删除字符串中指定的字符/*void delchar(char *str, char del)&#123; char *p = str; while (*str != '\0') &#123; if (*str != del) &#123; *p++ = *str; &#125; str++; &#125; *p = '\0';&#125;//删除最后一个字符int main()&#123; char str[] = "vencent ppqq"; delchar(str, 't'); printf("%s\n", str); system("pause");&#125;*///Java String replaceAll//StringBuffer buff.deleteCharAt(buff.length()-1);//删除最后一个字符/*void main(void)&#123; char str[] = "internet,"; str[strlen(str) - 1] = '\0'; printf("%s\n", str); //作业：realloc实现StringBuffer的拼接，而不是一开始开辟一个很大的数组 //结构体StringBuffer system("pause");&#125;*///memcpy 由src所指内存区域复制count个字节到dest所指内存区域/*void main(void)&#123; char src[] = "C,C++,Java"; char dest[20] = &#123; 0 &#125;; //字节 memcpy(dest, src, 5); printf("%s\n", dest); system("pause");&#125;*///memchr 从buf所指内存区域的前count个字节查找字符ch。/*void main(void)&#123; char src[] = "C,C++,Java"; char ch = 'C'; //字节 (分段截取) char* p = memchr(src + 3, ch, 5); if (p)&#123; printf("索引：%d\n", p - src); &#125; else&#123; printf("找不到\n"); &#125; system("pause");&#125;*///memmove 由src所指内存区域复制count个字节到dest所指内存区域。/*void main()&#123; char s[] = "Michael Jackson!"; //截取的效果 memmove(s, s + 8, strlen(s) - 8 - 1); s[strlen(s) - 8] = 0; printf("%s\n", s); getchar();&#125;*///在字符串s1中寻找字符串s2中任何一个字符相匹配的第一个字符的位置，空字符NULL不包括在内void main()&#123; char *s1 = "Welcome To Beijing"; char *s2 = "to"; char *p; p = strpbrk(s1, s2); if (p) printf("%s\n", p); else printf("Not Found!\n"); p = strpbrk(s1, "Da"); if (p) printf("%s", p); else printf("Not Found!"); getchar();&#125;]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_C语言</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本数据类型_输入输出_注意事项_指针]]></title>
    <url>%2F2019%2F09%2F27%2F07_31_C_01%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#define _CRT_SECURE_NO_WARNINGS //宏定义//引入头文件//只有函数的声明，编译时去找函数的实现#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;Windows.h&gt;/*void main()&#123; printf("hello world\n"); system("pause");&#125;*///1.基本数据类型//int short long float double char/*int %dshort %dlong %ldfloat %fdouble %lfchar %c%x 十六进制%o 八进制%s 字符串*//*void main()&#123; int i = 1; printf("%d\n", i); float f = 23.3; printf("%f\n", f); //基本数据类型所占的字节数 printf("int占%d字节\n", sizeof(int)); printf("char占%d字节\n", sizeof(char)); printf("float占%d字节\n", sizeof(float)); //循环 int n = 0; for (; n &lt; 10; n++)&#123; printf("%d\n",n); &#125; //等待输入,跟system("pause")差不多 getchar();&#125;*///2.输入输出函数/*void main()&#123; int i; printf("请输入一个整数："); //赋值 scanf("%d", &amp;i); //控制台输入，&amp;取地址符 //打印 printf("i的值为：%d\n", i); system("pause");&#125;*///指针//指针存储的是变量的内存地址//内存地址，系统给数据分配的编号(门牌号)/*void main()&#123; int i = 90; //指针变量，创建一个int类型的指针 int* p = &amp;i; //p的值就是i这个变量的内存地址 printf("%#x\n", p); float f = 89.5; //创建一个float类型的指针 float *fp = &amp;f; printf("%#x\n", fp); system("pause");&#125;*//*void change(int *p)&#123; *p = 300;&#125;//变量名，对内存空间上的一段数据的抽象void main()&#123; int i = 90; //i = 89; //创建一个int类型的指针 int *p = &amp;i; //输出地址 printf("p的地址：%#x\n", &amp;p); printf("i的地址：%#x\n", &amp;i); printf("i的值为：%d\n", i); //间接赋值 //*p = 200; //change(p); change(&amp;i); //int *p = &amp;i; printf("i的值为：%d\n", i); system("pause");&#125;*/void main()&#123; int time = 600; printf("time:%#x\n", &amp;time); while (time &gt; 0)&#123; time--; printf("游戏时间剩余%d秒\n", time); //睡眠 Sleep(1000); &#125; system("pause");&#125; 12345678#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;__declspec(dllexport) void go()&#123; //修改time变量的值 int *p = 0x50fb58; *p = 999999;&#125;]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_C语言</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结构体与结构体指针]]></title>
    <url>%2F2019%2F09%2F27%2F08_07_C_01%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#define _CRT_SECURE_NO_WARNINGS#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;Windows.h&gt;//结构体是一种构造数据类型//把不同的数据类型整合起来成为一个自定义的数据类型/*struct Man&#123; //成员 char name[20]; int age; //int(*func)();&#125;;void main()&#123; //初始化结构体的变量 //1. //struct Man m1 = &#123;"Jack",21&#125;; //2. struct Man m1; m1.age = 23; //m1.name = "Rose"; strcpy(m1.name, "rose"); sprintf(m1.name, "Jason"); //类似JavaScript字面量赋值，只能在变量声明时赋值 //m1 = &#123;&#125;; struct Man m2 = m1; printf("%s,%d\n", m1.name, m1.age); getchar();&#125;*///结构体的几种写法/*struct Man&#123; char name[20]; int age;&#125;m1, m2 = &#123;"jack",20&#125;; //m1,m2结构体变量名//typedef int Age;void main()&#123; strcpy(m1.name,"Jack"); m1.age = 10; printf("%s,%d,%s,%d",m1.name,m1.age,m2.name,m2.age); getchar();&#125;*///匿名结构体//控制结构体变量的个数（限量版)，相当于单例/*struct&#123; char name[20]; int age;&#125;m1;*///结构体嵌套/*struct Teacher&#123; char name[20];&#125;;struct Student&#123; char name[20]; int age; struct Teacher t;&#125;;void main()&#123; //字面量的方式 //struct Student s1 = &#123; "jack", 21, &#123;"Jason"&#125; &#125;; struct Student s1; s1.age = 10; strcpy(s1.t.name, "Jason"); system("pause");&#125;*///结构体嵌套2/*struct Student&#123; char name[20]; int age; struct Teacher&#123; char name[20]; &#125; t;&#125;;void main()&#123; struct Student s1; strcpy(s1.t.name, "Jason"); //struct Teacher t2; system("pause");&#125;*///结构体与指针/*struct Man&#123; char name[20]; int age;&#125;;void main()&#123; struct Man m1 = &#123; "jack", 30 &#125;; //结构体指针 struct Man *p = &amp;m1; printf("%s,%d\n", m1.name, m1.age); printf("%s,%d\n",(*p).name,(*p).age); //-&gt;(箭头)是"(*p)."简写形式 printf("%s,%d\n", p-&gt;name, p-&gt;age); system("pause");&#125;*///指针与结构体数组/*struct Man&#123; char name[20]; int age;&#125;;void main()&#123; struct Man mans[] = &#123; &#123; "Jack", 20 &#125;, &#123; "Rose", 19 &#125; &#125;; //遍历结构体数组 //1. struct Man *p = mans; for (; p &lt; mans + 2; p++)&#123; printf("%s,%d\n", p-&gt;name, p-&gt;age); &#125; //2. int i = 0; for (; i &lt; sizeof(mans)/sizeof(struct Man); i++)&#123; printf("%s,%d\n", mans[i].name, mans[i].age); &#125; system("pause");&#125;*///结构体的大小(字节对齐)//int：4个字节，double：8个字节,结构体的大小要能被最大的整除，所以该大小不是12个字节，而是16个字节/*struct Man&#123; int age; double weight;&#125;;void main()&#123; //结构体变量的大小，必须是最宽基本数据类型的整数倍 //提升读取的效率 struct Man m1 = &#123; 20, 89.0 &#125;; printf("%#x,%d\n",&amp;m1,sizeof(m1)); getchar();&#125;*///结构体与动态内存分配/*struct Man&#123; char *name; int age;&#125;;void main()&#123; struct Man *m_p = (struct Man*)malloc(sizeof(struct Man) * 10); struct Man *p = m_p; //赋值 p-&gt;name = "Jack"; p-&gt;age = 20; p++; p-&gt;name = "Rose"; p-&gt;age = 20; struct Man *loop_p = m_p; for (; loop_p &lt; m_p + 2; loop_p++)&#123; printf("%s, %d\n",loop_p-&gt;name,loop_p-&gt;age); &#125; free(m_p); getchar();&#125;*///typedef 类型取别名//1.不同名称代表在干不同的事情typedef int jint;//2.不同情况下，使用不同的别名//#if defined(_cplusplus)//typedef _JNIEnv JNIEnv//typedef _JavaVM JavaVM//3.书写简洁/*struct Man&#123; char name[20]; int age;&#125;;//Age int类型的别名typedef int Age;//Age int类型指针的别名typedef int* Ap;typedef struct Man JavaMan;typedef struct Man* JM;//结构体取别名typedef struct Woman&#123; char name[20]; int age;&#125;;// W, *WP; //W是Woman结构体的别名，WP是Woman结构体指针的别名typedef struct Woman W, *WP;void main()&#123; int i = 5; Ap p = &amp;i; //结构体变量 W w1 = &#123;"Rose",20&#125;; //结构体指针 WP wp1 = &amp;w1; printf("%s, %d\n", w1.name, w1.age); printf("%s, %d\n", wp1-&gt;name, wp1-&gt;age); getchar();&#125;*///结构体函数指针成员/*struct Girl&#123; char *name; int age; //函数指针 void(*sayHi)(char*);&#125;;//Girl结构体类似于Java中的类，name和age类似于属性，sayHi类似于方法void sayHi(char* text)&#123; MessageBox(0,text,"title",0);&#125;void main()&#123; struct Girl g1; g1.name = "Lucy"; g1.age = 18; g1.sayHi = sayHi; g1.sayHi("hello"); getchar();&#125;*/typedef struct Girl&#123; char *name; int age; //函数指针 void(*sayHi)(char*);&#125;Girl;//Girl结构体指针取别名GirlPtypedef Girl *GirlP;void sayHi(char* text)&#123; MessageBoxA(0, text, "title", 0);&#125;//改名void reName(GirlP gp1)&#123; gp1-&gt;name = "Lily";&#125;void main()&#123; Girl g1 = &#123;"Lucy",18,sayHi&#125;; GirlP gp1 = &amp;g1; gp1-&gt;sayHi("Bye"); //传递指针，改名 reName(gp1); printf("%s", gp1-&gt;name); getchar();&#125;]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_C语言</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[联合体_枚举]]></title>
    <url>%2F2019%2F09%2F27%2F08_08_C_01%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;//联合体（共用体）//不同类型的变量共同占用一段内存（相互覆盖）,联合变量任何时刻只有一个成员存在，节省内存//大小：联合体变量的大小=最大的成员所占的字节数//比喻：同穿一条裤子/*union MyValue&#123; int x; int y; double z;&#125;;void main()&#123; union MyValue d1; d1.x = 90; d1.y = 100;//最后一次赋值有效 //d1.z = 23.8; printf("%d,%d,%lf\n",d1.x,d1.y,d1.z); system("pause");&#125;*///枚举（列举所有的情况）//限定值，保证取值的安全性//enumerationenum Day&#123; Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday&#125;;void main()&#123; //枚举的值，必须是括号中的值 enum Day d = Monday; printf("%#x,%d\n", &amp;d, d); //int i = 0; //enum Day *p = &amp;d; //for (; i &lt; 7; i++)&#123; // printf("%#x,%d\n", p, *p); // p++;//枚举内存不是连续的 //&#125; getchar();&#125;]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_C语言</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件IO]]></title>
    <url>%2F2019%2F09%2F27%2F08_08_C_02%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304#define _CRT_SECURE_NO_WARNINGS#include "stdlib.h"#include "stdio.h"#include "string.h"//读取文本文件/*void main()&#123; char path[] = "F:\\android_study\\study_dongnaoxueyuan\\NDK_develop\\08_08_C_01\\files\\friends.txt"; //打开 FILE *fp = fopen(path,"r"); if (fp == NULL)&#123; printf("文件打开失败..."); return; &#125; //读取 char buff[50];//缓存 while (fgets(buff,50,fp))&#123; printf("%s", buff); &#125; //关闭 fclose(fp); system("pause"); getchar();&#125;*///写入文本文件/*void main()&#123; char path[] = "F:\\android_study\\study_dongnaoxueyuan\\NDK_develop\\08_08_C_01\\files\\friends_new.txt"; FILE *fp = fopen(path, "w"); char *text = "hchmily@sina.com,程华才,学清路8号\n科技财富中心A座9层"; fputs(text,fp); //关闭流 fclose(fp); getchar();&#125;*///计算机的文件存储在物理上都是二进制//文本文件和二进制之分，其实是一个逻辑之分//C读写文本文件与二进制文件的差别仅仅体现在回车换行符//写文本时，每遇到一个'\n',会将其转换成'\r\n'(回车换行)//读文本时，每遇到一个'\r\n',会将其转换成'\n'//文件复制/*void main()&#123; char *read_path = "F:\\android_study\\study_dongnaoxueyuan\\NDK_develop\\08_08_C_01\\files\\liuyan.png"; char *write_path = "F:\\android_study\\study_dongnaoxueyuan\\NDK_develop\\08_08_C_01\\files\\liuyan_new.png"; //读的文件 b(binary)字符表示操作二进制文件 FILE *read_fp = fopen(read_path, "rb"); //写的文件 FILE *write_fp = fopen(write_path, "wb"); //复制 char buff[50];//缓冲区域 int len = 0;//每次读取到的数据长度 while ((len = fread(buff, sizeof(char),50,read_fp))!=0)&#123; //将读到的内容写入新的文件 fwrite(buff, sizeof(char), len, write_fp); &#125; //关闭流 fclose(read_fp); fclose(write_fp); getchar();&#125;*///获取文件的大小/*void main()&#123; char *read_path = "F:\\android_study\\study_dongnaoxueyuan\\NDK_develop\\08_08_C_01\\files\\liuyan.png"; FILE *fp = fopen(read_path, "r"); //重新定位文件指针 //SEEK_END文件末尾,0偏移量 fseek(fp, 0, SEEK_END); //返回当前的文件指针，相对于文件开头的位移量 long filesize = ftell(fp); printf("%ld\n", filesize); getchar();&#125;*///练习：文本文件加解密/*//异或//规则：1^1=0,0^0=0,1^0=1,相同为0，不同为1//加密void encrypt(char normal_path[],char encrypt_path[])&#123; //打开文件 FILE *normal_fp = fopen(normal_path, "r"); FILE *encrypt_fp = fopen(encrypt_path, "w"); //一次读取一个字符 int ch; while ((ch = fgetc(normal_fp))!=EOF)&#123; //END of File //写入(异或运算) fputc(ch ^ 9, encrypt_fp); &#125; //关闭 fclose(encrypt_fp); fclose(normal_fp);&#125;//解密void decrypt(char encrypt_path[], char decrypt_path[])&#123; //打开文件 FILE *encrypt_fp = fopen(encrypt_path, "r"); FILE *decrypt_fp = fopen(decrypt_path, "w"); //一次读取一个字符 int ch; while ((ch = fgetc(encrypt_fp)) != EOF)&#123; //END of File //写入(异或运算) fputc(ch ^ 9, decrypt_fp); &#125; //关闭 fclose(encrypt_fp); fclose(decrypt_fp);&#125;void main()&#123; char *normal_path = "F:\\android_study\\study_dongnaoxueyuan\\NDK_develop\\08_08_C_01\\files\\friends.txt"; char *encrypt_path = "F:\\android_study\\study_dongnaoxueyuan\\NDK_develop\\08_08_C_01\\files\\friends_encrypt.txt"; char *decrypt_path = "F:\\android_study\\study_dongnaoxueyuan\\NDK_develop\\08_08_C_01\\files\\friends_decrypt.txt"; //encrypt(normal_path, encrypt_path); //解密 decrypt(encrypt_path, decrypt_path); getchar();&#125;*///二进制文件加解密//读取二进制文件中的数据时，一个一个字符读取//密码：ilovely/*void encrypt(char normal_path[], char encrypt_path[],char password[])&#123; //打开文件 FILE *normal_fp = fopen(normal_path, "rb"); FILE *encrypt_fp = fopen(encrypt_path, "wb"); //一次读取一个字符 int ch; int i = 0;//循环使用密码中的字母进行异或运算 int pwd_len = strlen(password);//密码长度 while ((ch = fgetc(normal_fp)) != EOF)&#123; //END of File //写入(异或运算) fputc(ch ^ password[i % pwd_len], encrypt_fp); i++; &#125; //关闭 fclose(encrypt_fp); fclose(normal_fp);&#125;//解密void decrypt(char encrypt_path[], char decrypt_path[],char password[])&#123; //打开文件 FILE *encrypt_fp = fopen(encrypt_path, "rb"); FILE *decrypt_fp = fopen(decrypt_path, "wb"); //一次读取一个字符 int ch; int i = 0;//循环使用密码中的字母进行异或运算 int pwd_len = strlen(password);//密码长度 while ((ch = fgetc(encrypt_fp)) != EOF)&#123; //END of File //写入(异或运算) fputc(ch ^ password[i % pwd_len], decrypt_fp); i++; &#125; //关闭 fclose(encrypt_fp); fclose(decrypt_fp);&#125;void main()&#123; char *normal_path = "F:\\android_study\\study_dongnaoxueyuan\\NDK_develop\\08_08_C_01\\files\\liuyan.png"; char *encrypt_path = "F:\\android_study\\study_dongnaoxueyuan\\NDK_develop\\08_08_C_01\\files\\liuyan_encrypt.png"; char *decrypt_path = "F:\\android_study\\study_dongnaoxueyuan\\NDK_develop\\08_08_C_01\\files\\liuyan_decrypt.png"; //encrypt(normal_path, encrypt_path,"iloveqq"); //解密 decrypt(encrypt_path, decrypt_path, "iloveqq"); getchar();&#125;*///作业：文件的分割以及合并/*void cut(char origin_path[],char cut_path1[],char cut_path2[])&#123; FILE *origin_fp = fopen(origin_path, "rb"); FILE *cut1_fp = fopen(cut_path1,"wb"); FILE *cut2_fp = fopen(cut_path2, "wb"); int ch; int i = 0; while ((ch = fgetc(origin_fp)) != EOF)&#123; if (i &lt; 380*1024)&#123; fputc(ch, cut1_fp); &#125; else&#123; fputc(ch, cut2_fp); &#125; i++; &#125; fclose(origin_fp); fclose(cut1_fp); fclose(cut2_fp);&#125;void merge(char cut_path1[], char cut_path2[], char merge_path[])&#123; FILE *merge_fp = fopen(merge_path, "ab"); FILE *cut1_fp = fopen(cut_path1, "rb"); FILE *cut2_fp = fopen(cut_path2, "rb"); int ch; while ((ch = fgetc(cut1_fp)) != EOF)&#123; fputc(ch, merge_fp); &#125; while ((ch = fgetc(cut2_fp)) != EOF)&#123; fputc(ch, merge_fp); &#125; fclose(merge_fp); fclose(cut1_fp); fclose(cut2_fp);&#125;void main()&#123; char *origin_path = "F:\\android_study\\study_dongnaoxueyuan\\NDK_develop\\08_08_C_01\\files\\liuyan.png"; char *cut_path1 = "F:\\android_study\\study_dongnaoxueyuan\\NDK_develop\\08_08_C_01\\files\\liuyan_cut1.png"; char *cut_path2 = "F:\\android_study\\study_dongnaoxueyuan\\NDK_develop\\08_08_C_01\\files\\liuyan_cut2.png"; char *merge_path = "F:\\android_study\\study_dongnaoxueyuan\\NDK_develop\\08_08_C_01\\files\\liuyan_merge.png"; //cut(origin_path,cut_path1,cut_path2); merge(cut_path1, cut_path2,merge_path); getchar();&#125;*/void cut(char origin_path[],char record_path[],int cutNum)&#123; FILE *origin_fp = fopen(origin_path, "rb"); FILE *record_fp = fopen(record_path, "w"); fseek(origin_fp, 0, SEEK_END); long filesize = ftell(origin_fp); long blockLen = filesize / cutNum; int i = 0; FILE *ftmp; for (; i &lt; cutNum; i++)&#123; char ftmp_path[100] = "F:\\android_study\\study_dongnaoxueyuan\\NDK_develop\\08_08_C_01\\files\\"; char ftmp_name[20]; sprintf(ftmp_name, "部分%d.tmp", i + 1); strcat(ftmp_path, ftmp_name); ftmp = fopen(ftmp_path, "wb"); if (ftmp == NULL)&#123; perror("分割文件出错"); break; &#125; fputs(ftmp_path, record_fp); fputc('\n', record_fp); long offset = i*blockLen; fseek(origin_fp, offset, SEEK_SET); int count = 0; if (i == cutNum - 1) blockLen = filesize - offset; while ((count &lt; blockLen) &amp;&amp; !feof(origin_fp))&#123; fputc(fgetc(origin_fp), ftmp); count++; &#125; printf("count:%d\n",count); fclose(ftmp); fclose(ftmp_path); &#125; fclose(record_fp); fclose(origin_fp);&#125;void merge(char record_path[], char dst_path[])&#123; FILE *record_fp = fopen(record_path, "r"); FILE *dst_fp = fopen(dst_path, "wb"); char ftmp_path[100]; FILE *tempFile; while (fgets(ftmp_path, 100, record_fp))&#123; ftmp_path[strlen(ftmp_path) - 1] = '\0'; tempFile = fopen(ftmp_path, "rb"); if (tempFile == NULL)&#123; printf("打开文件%s失败\n", ftmp_path); return; &#125; printf("正在合并%s到新文件\n", ftmp_path); char buf[50]; int len = 0; while ((len = fread(buf, sizeof(char), 50, tempFile)) != 0)&#123; fwrite(buf, sizeof(char), len, dst_fp); &#125; fclose(tempFile); &#125; fclose(dst_fp); fclose(record_fp);&#125;void main()&#123; char *origin_path = "F:\\android_study\\study_dongnaoxueyuan\\NDK_develop\\08_08_C_01\\files\\liuyan.png"; char *record_path = "F:\\android_study\\study_dongnaoxueyuan\\NDK_develop\\08_08_C_01\\files\\record.txt"; char *dst_path = "F:\\android_study\\study_dongnaoxueyuan\\NDK_develop\\08_08_C_01\\files\\liuyan_merge2.png"; //cut(origin_path, record_path, 3); merge(record_path, dst_path); getchar();&#125;]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_C语言</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[预编译指令]]></title>
    <url>%2F2019%2F09%2F27%2F08_10_C_01%2F</url>
    <content type="text"><![CDATA[01.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include"A.h"void printfA()&#123; printf("print A");&#125;//C语言执行的流程//编译：形成目标代码（.obj）//连接：将目标代码与C函数库连接合并，形成最终的可执行文件//执行//预编译（预处理），为编译做准备工作，完成代码文本的替换工作//E:\Visual Studio\VC\include//E:\Visual Studio\VC\crt\src//头文件告诉编译器有这样一个函数，连接器负责找到这个函数的实现//宏定义(宏替换、预编译指令)//define指令//1.定义标示//#ifdef __cplusplus 表示支持C++语法//防止文件重复引入//2.定义常数(便于修改和阅读)#define MAX 100//3.定义"宏函数"void dn_com_jni_read()&#123; printf("read\n");&#125;void dn_com_jni_write()&#123; printf("write\n");&#125;//NAME是参数#define jni(NAME) dn_com_jni_##NAME();//webrtc JNI函数名称很长，也是通过JOW宏函数缩短函数名称//日志输出//__VA_ARGS__代表可变参数//#define LOG(FORMAT,...) printf(FORMAT,__VA_ARGS__);//方法内部可以不带##，最好加上////日志会有级别//#define LOG_I(FORMAT,...) printf("INFO:"); printf(##FORMAT,__VA_ARGS__);//#define LOG_E(FORMAT,...) printf("ERROR:"); printf(##FORMAT,__VA_ARGS__);//升级版#define LOG(LEVEL,FORMAT,...) printf(LEVEL); printf(##FORMAT,__VA_ARGS__);#define LOG_I(FORMAT,...) LOG("INFO:",FORMAT,__VA_ARGS__);#define LOG_E(FORMAT,...) LOG("ERROR:",FORMAT,__VA_ARGS__);#define LOG_W(FORMAT,...) LOG("WARN:",FORMAT,__VA_ARGS__);void main()&#123; //#include "my.txt" //printfA(); int i = 90; if (i &lt; MAX)&#123; printf("比MAX小..."); &#125; jni(write);//替换：dn_com_jni_write() //LOG("%s%d","大小:",100); //LOG_I("%s%d", "大小:", 100); LOG_E("%s%d", "大小:", 100); getchar();&#125; A.h1234567891011121314//如果没有定义AH，定义AH(AH没有意义，就一个标识，可以随便定义)//如果没有定义AH，执行到endif的代码；定义了AH，#ifndef AH就不成立，就不执行了//#ifndef AH//#define AH//#include "B.h"////void printfA();////#endif//该头文件只被包含一次，让编译器自主处理好循环包含问题#pragma once#include "B.h"void printfA(); B.h1234567891011//#ifndef BH//#define BH//#include "A.h"////void printfB();////#endif#pragma once#include "A.h"void printfB(); my.txt1printf("%s\n","I am a little boy");]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_C语言</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JNI开发流程_JNIEnv]]></title>
    <url>%2F2019%2F09%2F27%2F08_10_C_02%2F</url>
    <content type="text"><![CDATA[JniTest.java123456789101112131415package com.hzh.jni;public class JniTest &#123; public native static String getStringFromC(); public static void main(String[] args)&#123; System.out.println(getStringFromC()); &#125; //加载动态库 static&#123; System.loadLibrary("jni_study"); &#125;&#125; com_hzh_jni_JniTest.h123456789101112131415161718192021/* DO NOT EDIT THIS FILE - it is machine generated */#include "jni.h"/* Header for class com_hzh_jni_JniTest */#ifndef _Included_com_hzh_jni_JniTest#define _Included_com_hzh_jni_JniTest#ifdef __cplusplusextern "C" &#123;#endif/* * Class: com_hzh_jni_JniTest * Method: getStringFromC * Signature: ()V */JNIEXPORT jstring JNICALL Java_com_hzh_jni_JniTest_getStringFromC (JNIEnv *, jclass);#ifdef __cplusplus&#125;#endif#endif 01.c12345678910111213#include "com_hzh_jni_JniTest.h"//函数实现JNIEXPORT jstring JNICALL Java_com_hzh_jni_JniTest_getStringFromC(JNIEnv *env, jclass jcls)&#123; //JNIEnv 结构体指针 //env 二级指针 //代表Java运行环境，调用Java中的代码 //简单的实现 //将C的字符串转为一个java字符串 return (*env)-&gt;NewStringUTF(env,"C String");&#125; 02.cpp123456789#include "com_hzh_jni_JniTest.h"//函数实现JNIEXPORT jstring JNICALL Java_com_hzh_jni_JniTest_getStringFromC(JNIEnv *env, jclass jcls)&#123; //JNIEnv在C++中就是一个结构体的别名 //env 在C++中是一个结构体的一级指针 return env-&gt;NewStringUTF("C String");&#125; 03.c1234567891011121314151617181920212223242526272829//JNIEnv就是结构体的指针别名typedef struct JNINativeInterface_* JNIEnv;//结构体struct JNINativeInterface_ &#123; char* (*NewStringUTF)(JNIEnv*, char*);&#125;;//函数实现char* NewStringUTF(JNIEnv* env, char* str)&#123; //在NewStringUTF执行过程中，仍然需要JNIEnv return str;&#125;void main()&#123; //实例化结构体 struct JNINativeInterface_ struct_env; struct_env.NewStringUTF = NewStringUTF; //结构体指针 JNIEnv e = &amp;struct_env; //结构体的二级指针 JNIEnv *env = &amp;e; //通过二级指针调用函数 char* str = (*env)-&gt;NewStringUTF(env, "abc");&#125;]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_JNI</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_JNI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串乱码_数据处理_JNI引用]]></title>
    <url>%2F2019%2F09%2F27%2F08_15_JNI_01%2F</url>
    <content type="text"><![CDATA[01.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//中文问题JNIEXPORT jstring JNICALL Java_com_hzh_jni_JniTest_chineseChars(JNIEnv *env, jobject jobj, jstring in)&#123; //输出 //char* c_str = (*env)-&gt;GetStringUTFChars(env, in, NULL); //printf("%s\n", c_str); //c -&gt; jstring char* c_str = "传出"; //char c_str[] = "传出"; //jstring jstr = (*env)-&gt;NewStringUTF(env, c_str); //执行String(byte bytes[], String charsetName)构造方法需要的条件 //1.jmethodID //2.byte数组 //3.字符编码jstring jclass str_cls = (*env)-&gt;FindClass(env, "java/lang/String"); jmethodID constructor_mid = (*env)-&gt;GetMethodID(env, str_cls, "&lt;init&gt;", "([BLjava/lang/String;)V"); //jbyte -&gt; char //jbyteArray -&gt; char[] jbyteArray bytes = (*env)-&gt;NewByteArray(env, strlen(c_str)); //byte数组赋值 //0-&gt;strlen(c_str)，从头到尾 //对等于，从c_str这个字符数组，复制到bytes这个字符数组 (*env)-&gt;SetByteArrayRegion(env, bytes, 0, strlen(c_str), c_str); //字符编码jstring jstring charsetName = (*env)-&gt;NewStringUTF(env, "GB2312"); //调用构造函数，返回编码之后的jstring return (*env)-&gt;NewObject(env, str_cls, constructor_mid, bytes, charsetName);&#125;int compare(int* a, int* b)&#123; return (*a) - (*b);&#125;//传入JNIEXPORT void JNICALL Java_com_hzh_jni_JniTest_giveArray(JNIEnv *env, jobject jobj, jintArray arr)&#123; //jintArray -&gt; jint指针 -&gt; c int 数组 jint *elems = (*env)-&gt;GetIntArrayElements(env, arr, NULL); //printf("%#x,%#x\n", &amp;elems, &amp;arr); //数组的长度 int len = (*env)-&gt;GetArrayLength(env, arr); //排序 qsort(elems,len,sizeof(jint),compare); //同步 //mode //0, Java数组进行更新，并且释放c/c++数组 //JNI_ABORT , Java数组不进行更新，但是释放c/c++数组 //JNI_COMMIT, Java数组进行更新，不释放c/c++数组(函数执行完，数组还是会释放) (*env)-&gt;ReleaseIntArrayElements(env, arr, elems, JNI_COMMIT);&#125;//返回数组JNIEXPORT jintArray JNICALL Java_com_hzh_jni_JniTest_getArray(JNIEnv *env, jobject jobj, jint len)&#123; //创建一个指定大小的数组 jintArray jint_arr = (*env)-&gt;NewIntArray(env, len); jint *elems = (*env)-&gt;GetIntArrayElements(env, jint_arr, NULL); int i = 0; for (; i &lt; len; i++)&#123; elems[i] = i; &#125; //同步 (*env)-&gt;ReleaseIntArrayElements(env, jint_arr, elems, 0); //在jni中 return jint_arr;&#125;//JNI 引用变量//引用类型：局部引用和全局引用//作用：在JNI中告知虚拟机何时回收一个JNI变量//局部引用，通过DeleteLocalRef手动释放对象//1.访问一个很大的java对象，使用完之后，还要进行复杂的耗时操作//2.创建了大量的局部引用，占用了太多的内存，而且这些局部引用跟后面的操作没有关联性//模拟：循环创建数组JNIEXPORT void JNICALL Java_com_hzh_jni_JniTest_localRef(JNIEnv *env, jobject jobj)&#123; int i = 0; for (; i &lt; 5; i++)&#123; //创建Date对象 jclass cls = (*env)-&gt;FindClass(env, "java/util/Date"); jmethodID constructor_mid = (*env)-&gt;GetMethodID(env, cls, "&lt;init&gt;", "()V"); jobject obj = (*env)-&gt;NewObject(env, cls, constructor_mid); //........ //不在使用object对象了 //通知垃圾回收器回收这些对象 (*env)-&gt;DeleteLocalRef(env, obj); //........ &#125;&#125;//全局引用//共享（可以跨多个线程），手动控制内存使用jstring global_str;//创建JNIEXPORT void JNICALL Java_com_hzh_jni_JniTest_createGlobalRef(JNIEnv *env, jobject jobj)&#123; jstring obj = (*env)-&gt;NewStringUTF(env, "jni development is powerful!"); global_str = (*env)-&gt;NewGlobalRef(env, obj);&#125;//获得JNIEXPORT jstring JNICALL Java_com_hzh_jni_JniTest_getGlobalRef(JNIEnv *env, jobject jobj)&#123; return global_str;&#125;//释放JNIEXPORT void JNICALL Java_com_hzh_jni_JniTest_deleteGlobalRef(JNIEnv *env, jobject jobj)&#123; (*env)-&gt;DeleteGlobalRef(env, global_str);&#125;//弱全局引用//节省内存，在内存不足时可以释放所引用的对象//可以引用一个不常用的对象，如果为NULL，再临时创建//创建：NewWeakGlobalRef,销毁：DeleteGlobalWeakRef JniTest.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.hzh.jni;import java.util.Date;import java.util.Random;import java.util.UUID;public class JniTest &#123; public native String chineseChars(String in); public native void giveArray(int[] array); public native int[] getArray(int len); public native void localRef(); public native void createGlobalRef(); public native String getGlobalRef(); public native void deleteGlobalRef(); public static void main(String[] args)&#123; System.out.println(getStringFromC()); JniTest t = new JniTest(); System.out.println(t.chineseChars("传入")); int[] array = &#123;9,100,10,37,5,10&#125;; //排序 t.giveArray(array); for (int i : array) &#123; System.out.println(i); &#125; //------ int[] array2 = t.getArray(10); System.out.println("-------------"); for (int i : array2) &#123; System.out.println(i); &#125; System.out.println("-------------"); t.createGlobalRef(); System.out.println(t.getGlobalRef()); //用完之后释放 t.deleteGlobalRef(); System.out.println("释放完了..."); System.out.println(t.getGlobalRef()); &#125; //加载动态库 static&#123; System.loadLibrary("jni_study"); &#125;&#125;]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_JNI</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_JNI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JNI数据类型_属性与方法访问]]></title>
    <url>%2F2019%2F09%2F27%2F08_12_JNI_01%2F</url>
    <content type="text"><![CDATA[01.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#define _CRT_SECURE_NO_WARNINGS#include "com_hzh_jni_JniTest.h"#include &lt;Windows.h&gt;#include&lt;string.h&gt;//函数实现JNIEXPORT jstring JNICALL Java_com_hzh_jni_JniTest_getStringFromC(JNIEnv *env, jclass jcls)&#123; //WinExec("D:\\常用软件\\Tencent\\TXEDU\\1.2.0.20\\bin\\TXEDU.exe", SW_SHOW); //JNIEnv 结构体指针 //env 二级指针 //代表Java运行环境，调用Java中的代码 //简单的实现 //将C的字符串转为一个java字符串 return (*env)-&gt;NewStringUTF(env,"C String");&#125;JNIEXPORT jstring JNICALL Java_com_hzh_jni_JniTest_getString2FromC(JNIEnv *env, jobject jobj,jint num)&#123; (*env)-&gt;NewStringUTF(env, "C String 2");&#125;//每个native函数，都至少有两个参数（JNIEnv*,jclass或者jobject）//1)当native方法为静态方法时://jclass代表native方法所属类的class对象(JniTest.class)//2)当native方法为非静态方法时://jobject代表native方法所属的对象//JNI基本数据//Java基本数据类型与JNI数据类型的映射关系//Java类型-&gt;JNI类型-&gt;C类型/*基本数据类型boolean jbooleanbyte jbytechar jcharshort jshortint jintlong jlongfloat jfloatdouble jfloatvoid void*///引用类型(对象)//String jstring//object jobject//数组，基本数据类型的数组//byte[] jByteArray//对象数组//object[](String[]) jobjectArray//C/C++访问Java的成员//1.访问属性//修改属性keyJNIEXPORT jstring JNICALL Java_com_hzh_jni_JniTest_accessField(JNIEnv *env, jobject jobj)&#123; //jobj是t对象，JniTest.class jclass cls = (*env)-&gt;GetObjectClass(env, jobj); //第三个参数：属性名称；第四个参数：属性签名 //获取签名方法,java应用程序bin目录下javap -s -p 完整类名 jfieldID fid = (*env)-&gt;GetFieldID(env, cls, "key", "Ljava/lang/String;"); //jason &gt;&gt; super jason //获取key属性的值 //get&lt;Type&gt;Field jstring jstr = (*env)-&gt;GetObjectField(env, jobj, fid); printf("jstr:%#x\n", &amp;jstr); //jstring -&gt; C字符串 //isCopy是否复制 //jboolean指针 jboolean isCopy = NULL; //函数内部复制了，isCopy为JNI_TRUE,没有复制为JNI_FALSE char *c_str = (*env)-&gt;GetStringUTFChars(env, jstr, &amp;isCopy); //if (isCopy)&#123; // //&#125; //意义：isCopy为JNI_FALSE，c_str和jstr都是指向同一个字符串，不能修改java字符串 //拼接得到新的字符串 char text[20] = "super "; strcat(text, c_str); //C字符串 -&gt; jstring jstring new_jstr = (*env)-&gt;NewStringUTF(env, text); //修改key //Set&lt;Type&gt;Field (*env)-&gt;SetObjectField(env, jobj, fid, new_jstr); printf("new_jstr:%#x\n", &amp;new_jstr); return new_jstr;&#125;//访问静态属性JNIEXPORT void JNICALL Java_com_hzh_jni_JniTest_accessStaticField(JNIEnv *env, jobject jobj)&#123; //jclass jclass cls = (*env)-&gt;GetObjectClass(env, jobj); //jfieldID jfieldID fid = (*env)-&gt;GetStaticFieldID(env, cls, "count", "I"); //GetStatic&lt;Type&gt;Field jint count = (*env)-&gt;GetStaticIntField(env, cls, fid); count++; //修改 //SetStatic&lt;Type&gt;Field (*env)-&gt;SetStaticIntField(env, cls, fid, count);&#125;//2.访问java方法JNIEXPORT void JNICALL Java_com_hzh_jni_JniTest_accessMethod(JNIEnv *env, jobject jobj)&#123; //jclass jclass cls = (*env)-&gt;GetObjectClass(env, jobj); //jmethodID jmethodID mid = (*env)-&gt;GetMethodID(env, cls, "getRandomInt", "(I)I"); //调用 //Call&lt;Type&gt;Method jint random = (*env)-&gt;CallIntMethod(env, jobj, mid, 200); printf("random num:%ld",random); //......&#125;//静态方法JNIEXPORT void JNICALL Java_com_hzh_jni_JniTest_accessStaticMethod(JNIEnv *env, jobject jobj)&#123; //jclass jclass cls = (*env)-&gt;GetObjectClass(env, jobj); //jmethodID jmethodID mid = (*env)-&gt;GetStaticMethodID(env, cls, "getUUID", "()Ljava/lang/String;"); //调用 //CallStatic&lt;Type&gt;Method jstring uuid = (*env)-&gt;CallStaticObjectMethod(env, cls, mid); //随机文件名称 //jstring -&gt; char* //isCopy char *uuid_str = (*env)-&gt;GetStringUTFChars(env, uuid, NULL); //拼接 char filename[100]; sprintf(filename, "D:\\%s.txt", uuid_str); FILE *fp = fopen(filename, "w"); fputs("i love c", fp); fclose(fp);&#125;//访问构造方法//使用java.util.Date产生一个当前的时间戳JNIEXPORT jobject JNICALL Java_com_hzh_jni_JniTest_accessConstructor(JNIEnv *env, jobject jobj)&#123; jclass cls = (*env)-&gt;FindClass(env, "java/util/Date"); //jmethodID jmethodID constructor_mid = (*env)-&gt;GetMethodID(env, cls, "&lt;init&gt;", "()V"); //实例化一个Date对象 jobject date_obj = (*env)-&gt;NewObject(env, cls, constructor_mid); //调用getTime方法 jmethodID mid = (*env)-&gt;GetMethodID(env, cls, "getTime", "()J"); jlong time = (*env)-&gt;CallLongMethod(env, date_obj, mid); printf("time:%lld\n", time); return date_obj;&#125;//调用父类的方法JNIEXPORT void JNICALL Java_com_hzh_jni_JniTest_accessNonvirtualMethod(JNIEnv *env, jobject jobj)&#123; jclass cls = (*env)-&gt;GetObjectClass(env, jobj); //获取man属性(对象) jfieldID fid = (*env)-&gt;GetFieldID(env, cls, "human", "Lcom/hzh/jni/Human;"); //获取 jobject human_obj = (*env)-&gt;GetObjectField(env, jobj, fid); //执行sayHi方法 jclass human_cls = (*env)-&gt;FindClass(env, "com/hzh/jni/Human");//注意：传父类的名称 jmethodID mid = (*env)-&gt;GetMethodID(env, human_cls, "sayHi", "()V"); //执行 //(*env)-&gt;CallObjectMethod(env, human_obj, mid); //调用父类的方法 (*env)-&gt;CallNonvirtualObjectMethod(env, human_obj, human_cls, mid);&#125; JniTest.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.hzh.jni;import java.util.Random;import java.util.UUID;public class JniTest &#123; public String key = "jason"; public static int count = 9; public native static String getStringFromC(); public native String getString2FromC(int i); //访问属性，返回修改之后的属性内容 public native String accessField(); public native void accessStaticField(); public native void accessMethod(); public native void accessStaticMethod(); public native Date accessConstructor(); public native void accessNonvirtualMethod(); public static void main(String[] args)&#123; System.out.println(getStringFromC()); JniTest t = new JniTest(); String text2 = t.getString2FromC(6); System.out.println(text2); System.out.println("key修改前：" + t.key); t.accessField(); System.out.println("key修改后：" + t.key); System.out.println("count修改前:"+count); t.accessStaticField(); System.out.println("count修改后:"+count); t.accessMethod(); t.accessStaticMethod(); t.accessConstructor(); t.accessNonvirtualMethod(); &#125; //产生指定范围的随机数 public int getRandomInt(int max)&#123; System.out.println("getRandomInt执行了..."); return new Random().nextInt(max); &#125; //产生UUID字符串 public static String getUUID()&#123; return UUID.randomUUID().toString(); &#125; //加载动态库 static&#123; System.loadLibrary("jni_study"); &#125;&#125; Human.java1234567package com.hzh.jni;public class Human &#123; public void sayHi()&#123; System.out.println("人打招呼..."); &#125;&#125; Man.java12345678910111213package com.hzh.jni;public class Man extends Human&#123; @Override public void sayHi()&#123; System.out.println("男人打招呼..."); &#125; public void sayHi2()&#123; super.sayHi(); &#125;&#125;]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_JNI</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_JNI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常处理_缓存策略]]></title>
    <url>%2F2019%2F09%2F27%2F08_17_JNI_01%2F</url>
    <content type="text"><![CDATA[01.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//异常处理//1.保证Java代码可以运行//2.补救措施保证C代码继续运行//JNI自己抛出的Throwable异常//用户通过ThrowNew抛出的异常可以在Java层捕捉JNIEXPORT void JNICALL Java_com_hzh_jni_JniTest_execption(JNIEnv *env, jobject jobj)&#123; jclass cls = (*env)-&gt;GetObjectClass(env, jobj); jfieldID fid = (*env)-&gt;GetFieldID(env, cls, "key2", "Ljava/lang/String;"); ////检测是否发生Java异常 //jthrowable exception = (*env)-&gt;ExceptionOccurred(env); //if (exception != NULL)&#123; // //让Java代码可以继续运行 // //清空异常信息 // (*env)-&gt;ExceptionClear(env); // //补救措施 // fid = (*env)-&gt;GetFieldID(env, cls, "key", "Ljava/lang/String;"); //&#125; ////获取属性的值 //jstring jstr = (*env)-&gt;GetObjectField(env, jobj, fid); //char* str = (*env)-&gt;GetStringUTFChars(env, jstr, NULL); ////对比属性值是否合法 //if (_stricmp(str, "super jason") != 0)&#123; // //人为抛出异常，给Java层处理 // jclass newExcCls = (*env)-&gt;FindClass(env, "java/lang/IllegalArgumentException"); // (*env)-&gt;ThrowNew(env, newExcCls, "key's value is invalid!"); //&#125;&#125;//缓存策略JNIEXPORT void JNICALL Java_com_hzh_jni_JniTest_cached(JNIEnv *env, jobject jobj)&#123; jclass cls = (*env)-&gt;GetObjectClass(env, jobj); //获取jfieldID只获取一次 //局部静态变量 static jfieldID key_id = NULL; if (key_id == NULL)&#123; key_id = (*env)-&gt;GetFieldID(env, cls, "key", "Ljava/lang/String;"); printf("----------GetFieldID--------\n"); &#125;&#125;//初始化全局变量，动态库加载完成之后，立刻缓存起来jfieldID key_fid;jmethodID random_mid;JNIEXPORT void JNICALL Java_com_hzh_jni_JniTest_initIds(JNIEnv *env, jclass jcls)&#123; key_fid = (*env)-&gt;GetFieldID(env, jcls, "key", "Ljava/lang/String;"); random_mid = (*env)-&gt;GetMethodID(env, jcls, "getRandomInt", "(I)I");&#125; JniTest.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class JniTest &#123; public String key = "jason1"; public native void execption(); public native void cached(); public native static void initIds(); public static void main(String[] args)&#123; System.out.println(getStringFromC()); JniTest t = new JniTest(); try&#123; t.execption(); &#125;catch(Throwable e)&#123; System.out.println("发生异常："+e.getMessage()); &#125; System.out.println("------异常发生之后------"); //不断调用cached方法 for(int i = 0;i&lt;100;i++)&#123; t.cached(); &#125; &#125; //产生指定范围的随机数 public int getRandomInt(int max)&#123; System.out.println("getRandomInt执行了..."); return new Random().nextInt(max); &#125; //产生UUID字符串 public static String getUUID()&#123; return UUID.randomUUID().toString(); &#125; //加载动态库 static&#123; System.loadLibrary("jni_study"); initIds(); &#125;&#125;]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_JNI</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_JNI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件拆分与合并]]></title>
    <url>%2F2019%2F09%2F27%2F08_19_NDK%2F</url>
    <content type="text"><![CDATA[NDKFileUtils.java12345678910111213141516171819202122232425package com.hzh.ndk_file_patch;public class NDKFileUtils &#123; static &#123; System.loadLibrary("ndk_file_patch"); &#125; /** * 拆分 * @param path * @param path_pattern * @param count */ public native static void diff(String path,String path_pattern,int count); /** * 合并 * @param path_pattern * @param count * @param total */ public native static void patch(String path_pattern,int count,String merge_patch);&#125; ndk_file_patch.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include "com_hzh_ndk_file_patch_NDKFileUtils.h"#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;android/log.h&gt;#define LOGI(FORMAT,...) __android_log_print(ANDROID_LOG_INFO,"hzh",FORMAT,__VA_ARGS__);#define LOGE(FORMAT,...) __android_log_print(ANDROID_LOG_ERROR,"hzh",FORMAT,__VA_ARGS__);//获取文件大小long get_file_size(char* path)&#123; FILE *fp = fopen(path,"rb"); fseek(fp,0,SEEK_END); return ftell(fp);&#125;//拆分JNIEXPORT void JNICALL Java_com_hzh_ndk_1file_1patch_NDKFileUtils_diff (JNIEnv *env, jclass jcls, jstring path_jstr, jstring path_pattern_jstr,jint file_num)&#123; //jstring -&gt; char* //需要分割的文件路径 const char *path = (*env)-&gt;GetStringUTFChars(env, path_jstr,NULL); const char *path_pattern = (*env)-&gt;GetStringUTFChars(env, path_pattern_jstr, NULL); //得到分割之后的子文件的路径列表 char **patches = malloc(sizeof(char*) * file_num); int i = 0; for (; i &lt; file_num; i++) &#123; patches[i] = malloc(sizeof(char) * 100); //元素赋值 //需要分割的文件：C://jason/liuyan.png //子文件：C://jason/liuyan_%d.png sprintf(patches[i],path_pattern,(i+1)); LOGI("path path:%s",patches[i]); &#125; //不断读取path文件，循环写入file_num个文件中 // 整除 // 文件大小：90，分成9个文件，每个文件10 // 不整除 // 文件大小：110，分成9个文件 // 前（9-1）个文件为(110/(9-1))=13 // 最后一个文件(110%(9-1))=6 int filesize = get_file_size(path); FILE *fpr = fopen(path,"rb"); //整除 if(filesize % file_num == 0)&#123; //单个文件大小 int part = filesize / file_num; i = 0; //逐一写入不同的分割子文件中 for(;i &lt; file_num;i++)&#123; FILE *fpw = fopen(patches[i],"wb"); int j = 0; for(; j &lt; part;j++)&#123; //边读边写 fputc(fgetc(fpr),fpw); &#125; fclose(fpw); &#125; &#125;else&#123; //不整除 int part = filesize / (file_num - 1); i = 0; for(;i &lt; file_num - 1;i++)&#123; FILE *fpw = fopen(patches[i],"wb"); int j = 0; for(; j &lt; part;j++)&#123; //边读边写 fputc(fgetc(fpr),fpw); &#125; fclose(fpw); &#125; //the last one FILE *fpw = fopen(patches[file_num-1],"wb"); i = 0; for(; i &lt; filesize%(file_num - 1);i++)&#123; fputc(fgetc(fpr),fpw); &#125; fclose(fpw); &#125; //关闭被分割的文件 fclose(fpr); //释放 i = 0; for(;i &lt; file_num;i++)&#123; free(patches[i]); &#125; free(patches); (*env)-&gt;ReleaseStringUTFChars(env,path_jstr,path); (*env)-&gt;ReleaseStringUTFChars(env,path_pattern_jstr,path_pattern);&#125;//合并JNIEXPORT void JNICALL Java_com_hzh_ndk_1file_1patch_NDKFileUtils_patch (JNIEnv *env, jclass jcls, jstring path_pattern_jstr, jint file_num,jstring merge_path_jstr)&#123; //合并之后的文件 const char *merge_path = (*env)-&gt;GetStringUTFChars(env, merge_path_jstr,NULL); //分割子文件的pattern const char *path_pattern = (*env)-&gt;GetStringUTFChars(env, path_pattern_jstr,NULL); //得到分割之后的子文件的路径列表 char **patches = malloc(sizeof(char*) * file_num); int i = 0; for (; i &lt; file_num; i++) &#123; patches[i] = malloc(sizeof(char) * 100); //元素赋值 //需要分割的文件：C://jason/liuyan.png //子文件：C://jason/liuyan_%d.png sprintf(patches[i],path_pattern,(i+1)); LOGI("path path:%s",patches[i]); &#125; FILE *fpw = fopen(merge_path,"wb"); //把所有的分割文件读取一遍，写入一个总的文件中 i = 0; for(; i &lt; file_num;i++)&#123; //每个子文件的大小 int filesize = get_file_size(patches[i]); FILE *fpr = fopen(patches[i],"rb"); int j = 0; for(; j &lt; filesize; j++)&#123; fputc(fgetc(fpr),fpw); &#125; fclose(fpr); &#125; fclose(fpw); //释放 i = 0; for(;i &lt; file_num;i++)&#123; free(patches[i]); &#125; free(patches); (*env)-&gt;ReleaseStringUTFChars(env,merge_path_jstr,merge_path); (*env)-&gt;ReleaseStringUTFChars(env,path_pattern_jstr,path_pattern);&#125; com_hzh_ndk_file_patch_NDKFileUtils.h1234567891011121314151617181920212223242526272829/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class com_hzh_ndk_file_patch_NDKFileUtils */#ifndef _Included_com_hzh_ndk_file_patch_NDKFileUtils#define _Included_com_hzh_ndk_file_patch_NDKFileUtils#ifdef __cplusplusextern "C" &#123;#endif/* * Class: com_hzh_ndk_file_patch_NDKFileUtils * Method: diff * Signature: (Ljava/lang/String;I)V */JNIEXPORT void JNICALL Java_com_hzh_ndk_1file_1patch_NDKFileUtils_diff (JNIEnv *, jclass, jstring, jstring ,jint);/* * Class: com_hzh_ndk_file_patch_NDKFileUtils * Method: patch * Signature: (Ljava/lang/String;I)V */JNIEXPORT void JNICALL Java_com_hzh_ndk_1file_1patch_NDKFileUtils_patch (JNIEnv *, jclass, jstring,jint,jstring);#ifdef __cplusplus&#125;#endif#endif CMakeLists.txt12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# For more information about using CMake with Android Studio, read the# documentation: https://d.android.com/studio/projects/add-native-code.html# Sets the minimum version of CMake required to build the native library.cmake_minimum_required(VERSION 3.4.1)# Creates and names a library, sets it as either STATIC# or SHARED, and provides the relative paths to its source code.# You can define multiple libraries, and CMake builds them for you.# Gradle automatically packages shared libraries with your APK.#C 的编译选项是 CMAKE_C_FLAGS# 指定编译参数，可选#SET(CMAKE_CXX_FLAGS "-Wno-error=format-security -Wno-error=pointer-sign")#设置生成的so动态库最后输出的路径set(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;/../jniLibs/$&#123;ANDROID_ABI&#125;)#设置头文件搜索路径（和此txt同个路径的头文件无需设置），可选#INCLUDE_DIRECTORIES($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/common)#指定用到的系统库或者NDK库或者第三方库的搜索路径，可选。#LINK_DIRECTORIES(/usr/local/lib)add_library( # Sets the name of the library. ndk_file_patch # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). src/main/cpp/ndk_file_patch.c )# Searches for a specified prebuilt library and stores the path as a# variable. Because CMake includes system libraries in the search path by# default, you only need to specify the name of the public NDK library# you want to add. CMake verifies that the library exists before# completing its build.find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log )# Specifies libraries CMake should link to your target library. You# can link multiple libraries, such as libraries you define in this# build script, prebuilt third-party libraries, or system libraries.target_link_libraries( # Specifies the target library. ndk_file_patch # Links the target library to the log library # included in the NDK. $&#123;log-lib&#125; )]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_JNI</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_JNI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[增量更新]]></title>
    <url>%2F2019%2F09%2F27%2F08_22_NDK%2F</url>
    <content type="text"><![CDATA[BsDiff.java12345678910111213141516package com.hzh.bsdiff;public class BsDiff &#123; /** * 差分 * @param oldfile * @param newfile * @param patchfile */ public native static void diff(String oldfile,String newfile,String patchfile); static&#123; System.loadLibrary("bsdiff"); &#125;&#125; BsDiffTest.java1234567891011package com.hzh.bsdiff;public class BsDiffTest &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub BsDiff.diff(ConstantsWin.OLD_APK_PATH, ConstantsWin.NEW_APK_PATH, ConstantsWin.PATCH_APK_PATH); &#125;&#125; ConstantsWin.java12345678910package com.hzh.bsdiff;public class ConstantsWin &#123; //路径不能包含中文 public static final String OLD_APK_PATH = "F:/android_study/study_dongnaoxueyuan/NDK_develop/08_22_NDK/app_update/app/release/app_old.apk"; public static final String NEW_APK_PATH = "F:/android_study/study_dongnaoxueyuan/NDK_develop/08_22_NDK/app_update/app/release/app_new.apk"; public static final String PATCH_APK_PATH = "F:/android_study/study_dongnaoxueyuan/NDK_develop/08_22_NDK/app_update/app/release/apk.patch";&#125; bsdiff.cpp12345678910111213141516171819//JNI 调用JNIEXPORT void JNICALL Java_com_hzh_bsdiff_BsDiff_diff(JNIEnv *env, jclass jcls, jstring oldfile_jstr, jstring newfile_jstr, jstring patchfile_jstr)&#123; int argc = 4; char* oldfile = (char*)env-&gt;GetStringUTFChars(oldfile_jstr, NULL); char* newfile = (char*)env-&gt;GetStringUTFChars(newfile_jstr, NULL); char* patchfile = (char*)env-&gt;GetStringUTFChars(patchfile_jstr, NULL); //参数(第一个参数无效) char* argv[4]; argv[0] = "bsdiff"; argv[1] = oldfile; argv[2] = newfile; argv[3] = patchfile; bsdiff_main(argc, argv); env-&gt;ReleaseStringUTFChars(oldfile_jstr, oldfile); env-&gt;ReleaseStringUTFChars(newfile_jstr, newfile); env-&gt;ReleaseStringUTFChars(patchfile_jstr, patchfile);&#125; bspatch.c1234567891011121314151617JNIEXPORT void JNICALL Java_com_hzh_app_1update_utils_BsPatch_patch (JNIEnv *env, jclass jcls, jstring oldfile_jstr, jstring newfile_jstr, jstring patchfile_jstr)&#123; int argc = 4; char* oldfile = (char*)(*env)-&gt;GetStringUTFChars(env,oldfile_jstr, NULL); char* newfile = (char*)(*env)-&gt;GetStringUTFChars(env,newfile_jstr, NULL); char* patchfile = (char*)(*env)-&gt;GetStringUTFChars(env,patchfile_jstr, NULL); //参数(第一个参数无效) char* argv[4]; argv[0] = "bspatch"; argv[1] = oldfile; argv[2] = newfile; argv[3] = patchfile; bspatch_main(argc, argv); (*env)-&gt;ReleaseStringUTFChars(env,oldfile_jstr, oldfile); (*env)-&gt;ReleaseStringUTFChars(env,newfile_jstr, newfile); (*env)-&gt;ReleaseStringUTFChars(env,patchfile_jstr, patchfile);&#125; BsPatch.java123456789101112131415package com.hzh.app_update.utils;public class BsPatch &#123; /** * 合并 * @param oldfile * @param newfile * @param patchfile */ public native static void patch(String oldfile,String newfile,String patchfile); static &#123; System.loadLibrary("bspatch"); &#125;&#125; bspatch方法调用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061static class ApkUpdateTask extends AsyncTask&lt;Void,Void,Boolean&gt;&#123; private WeakReference&lt;MainActivity&gt; mWeakReference; public ApkUpdateTask(MainActivity activity) &#123; mWeakReference = new WeakReference&lt;&gt;(activity); &#125; @Override protected Boolean doInBackground(Void... voids) &#123; try &#123; MainActivity mainActivity = mWeakReference.get(); if (mainActivity!=null)&#123; //1.下载差分包 Log.d("hzh","开始下载"); File patchFile = DownloadUtils.download(Constants.URL_PATCH_DOWNLOAD); //获取当前应用的apk文件/data/app/ .apk String oldfile = ApkUtils.getSourceApkPath(mainActivity,mainActivity.getPackageName()); Log.d("hzh","oldfile:" + oldfile); Log.d("hzh","newfile:" + Constants.NEW_APK_PATH); Log.d("hzh","patchfile:" + patchFile.getAbsolutePath()); File file = new File(Constants.SD_CARD); if (!file.exists())&#123; file.mkdir(); &#125; //2.合并得到最新版本的apk文件，新生成的apk文件所在目录一定要存在(否则bspatch_main方法执行失败) BsPatch.patch(oldfile,Constants.NEW_APK_PATH,patchFile.getAbsolutePath()); Log.d("hzh","合并完成"); &#125; &#125;catch (Exception e)&#123; Log.d("hzh","exception = "+e.getMessage()); return false; &#125; return true; &#125; @Override protected void onPostExecute(Boolean result) &#123; super.onPostExecute(result); //3.安装 if (result)&#123; MainActivity mainActivity = mWeakReference.get(); if (mainActivity!=null)&#123; Toast.makeText(mainActivity, "您正在进行无流量更新", Toast.LENGTH_SHORT).show(); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O)&#123; boolean haveInstallPermission = mainActivity.getPackageManager().canRequestPackageInstalls(); if (!haveInstallPermission) &#123; Uri packageURI = Uri.parse("package:" + mainActivity.getPackageName()); //注意这个是8.0新API Intent intent = new Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES, packageURI); mainActivity.startActivityForResult(intent, INSTALL_REQUEST_CODE); &#125;else&#123; ApkUtils.installApk(mainActivity,Constants.NEW_APK_PATH); &#125; &#125;else&#123; ApkUtils.installApk(mainActivity,Constants.NEW_APK_PATH); &#125; &#125; &#125; &#125; &#125; ApkUtils.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.hzh.app_update.utils;import android.content.Context;import android.content.Intent;import android.content.pm.ApplicationInfo;import android.content.pm.PackageManager;import android.net.Uri;import android.os.Build;import android.support.v4.content.FileProvider;import android.text.TextUtils;import java.io.File;public class ApkUtils &#123; /** * 获取已安装Apk文件的源Apk文件 * @param context * @param packageName * @return */ public static String getSourceApkPath(Context context,String packageName)&#123; if (TextUtils.isEmpty(packageName))&#123; return null; &#125; try &#123; ApplicationInfo appInfo = context.getPackageManager().getApplicationInfo(packageName,0); return appInfo.sourceDir; &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; return null; &#125; public static void installApk(Context context, String apkPath) &#123; Intent i = new Intent(Intent.ACTION_VIEW); i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); File file = new File(apkPath); Uri uri; if (Build.VERSION.SDK_INT &gt;= 24)&#123; i.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION); uri = FileProvider.getUriForFile(context,"com.hzh.app_update.fileprovider",file); &#125;else&#123; uri = Uri.fromFile(file); &#125; i.setDataAndType(uri, "application/vnd.android.package-archive"); context.startActivity(i); &#125;&#125; Constants.java12345678910111213141516package com.hzh.app_update.utils;import com.hzh.app_update.BaseApplication;import java.io.File;public class Constants &#123; public static final String PATCH_FILE = "apk.patch"; public static final String URL_PATCH_DOWNLOAD = "https://192.168.0.189:8443/app_update_server/" + PATCH_FILE; public static final String SD_CARD = FileUtils.getOwnCacheDirectory(BaseApplication.getApplication(),"hzhappupdate").getAbsolutePath() + File.separatorChar; public static final String NEW_APK_PATH = SD_CARD + "app_new.apk"; public static final String PATCH_FILE_PATH = SD_CARD + PATCH_FILE;&#125; FileUtils.java12345678910111213141516171819202122232425262728293031package com.hzh.app_update.utils;import android.content.Context;import android.os.Environment;import android.util.Log;import com.hzh.app_update.BaseApplication;import java.io.File;public class FileUtils &#123; public static File getOwnCacheDirectory(Context context, String cacheDir) &#123; File appCacheDir = null; Log.d("hzh","hasExternalStoragePermission:"+hasExternalStoragePermission(BaseApplication.getApplication())+",mounted.equals(Environment.getExternalStorageState()):"+"mounted".equals(Environment.getExternalStorageState())); if ("mounted".equals(Environment.getExternalStorageState()) &amp;&amp; hasExternalStoragePermission(context)) &#123; appCacheDir = new File(Environment.getExternalStorageDirectory(), cacheDir); Log.d("hzh","appCacheDir.canWrite:"+appCacheDir.canWrite()); &#125; if (appCacheDir == null || !appCacheDir.exists() &amp;&amp; !appCacheDir.mkdirs() || !appCacheDir.canWrite()) &#123; appCacheDir = context.getCacheDir(); &#125; return appCacheDir; &#125; private static boolean hasExternalStoragePermission(Context context) &#123; int perm = context.checkCallingOrSelfPermission("android.permission.WRITE_EXTERNAL_STORAGE"); return perm == 0; &#125;&#125; AndroidManifest.xml123456789101112131415&lt;application ... android:name=".BaseApplication" android:networkSecurityConfig="@xml/network_security_config"&gt; &lt;provider android:authorities="com.hzh.app_update.fileprovider" android:name="android.support.v4.content.FileProvider" android:grantUriPermissions="true" android:exported="false"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/filepaths" /&gt; &lt;/provider&gt; &lt;/application&gt; filepaths.xml123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;paths&gt; &lt;external-path path="" name="update"/&gt; &lt;files-path path="" name="update_2"/&gt; &lt;cache-path path="" name="update_3"/&gt;&lt;/paths&gt; network_security_config.xml123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;network-security-config&gt; &lt;domain-config&gt; &lt;domain includeSubdomains="true"&gt;192.168.0.189&lt;/domain&gt; &lt;trust-anchors&gt; &lt;certificates src="@raw/tomcat"/&gt; &lt;/trust-anchors&gt; &lt;/domain-config&gt;&lt;/network-security-config&gt;]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_JNI</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_JNI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++命名空间_引用_函数默认参数_可变参数]]></title>
    <url>%2F2019%2F09%2F27%2F08_24_C%2B%2B%2F</url>
    <content type="text"><![CDATA[01.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375#include&lt;stdlib.h&gt;#include&lt;iostream&gt;#include&lt;stdarg.h&gt;//标准命名空间(包含很多标准的定义)//standardusing namespace std;//命名空间类似于Java中的包(归类)/*//自定义命名空间namespace NSP_A&#123; int a = 9; struct Student&#123; char name[20]; int age; &#125;; struct Teacher&#123; char name[20]; int age; &#125;;&#125;namespace NSP_B&#123; int a = 12; //命名空间嵌套 namespace NSP_C&#123; int c = 90; &#125; struct Student&#123; char name[20]; int age; &#125;;&#125;void main()&#123; //运算符重载 //std::cout &lt;&lt; "this is c plus plus" &lt;&lt; std::endl; cout &lt;&lt; "this is c plus plus" &lt;&lt; endl; //使用命名空间 //::访问修饰符 cout &lt;&lt; NSP_A::a &lt;&lt; endl; cout &lt;&lt; NSP_B::a &lt;&lt; endl; cout &lt;&lt; NSP_B::NSP_C::c &lt;&lt; endl; //使用命名空间中的结构体 //using namespace NSP_A; //struct NSP_A::Teacher t; using NSP_A::Teacher; Teacher t; t.age = 10; using namespace NSP_B; Student s1; system("pause");&#125;*//*#define PI 3.14//圆class MyCircle&#123;//属性(共用权限访问修饰符)private: double r; double s;public: void setR(double r)&#123; this-&gt;r = r; &#125; //获取面积 double getS()&#123; return PI * r * r; &#125;&#125;;void main()&#123; MyCircle c1; c1.setR(4); cout &lt;&lt; "圆的面积：" &lt;&lt; c1.getS() &lt;&lt; endl; system("pause");&#125;*///结构体/*struct MyTeacher&#123;private: char name[20]; int age;public: void say()&#123; cout &lt;&lt; this-&gt;age &lt;&lt; "岁" &lt;&lt; endl; &#125; void setAge(int age)&#123; this-&gt;age = age; &#125;&#125;;void main()&#123; MyTeacher t1; t1.setAge(10); t1.say(); system("pause");&#125;*///布尔类型/*void main()&#123; bool isSingle = true; if (isSingle)&#123;//不为0条件都成立 cout &lt;&lt; "单身" &lt;&lt; endl; &#125; else&#123; cout &lt;&lt; "有对象" &lt;&lt; endl; &#125; int a = 10, b = 20; ((a &gt; b) ? a : b) = 30; cout &lt;&lt; b &lt;&lt; endl; system("pause");&#125;*///引用/*void main()&#123; //变量名-门牌号(内存空间0x0001的别名) int a = 10; //b就是这个内存空间另外一个别名 //&amp; C++中的引用 int &amp;b = a; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; "&amp;a:" &lt;&lt; &amp;a &lt;&lt; ",&amp;b:" &lt;&lt; &amp;b &lt;&lt; endl; system("pause");&#125;*//*//指针值交换void swap_1(int *a, int *b)&#123; int c = 0; c = *a; *a = *b; *b = c;&#125;//引用值交换void swap_2(int &amp;a, int &amp;b)&#123; int c = 0; c = a; a = b; b = c;&#125;void main()&#123; int x = 10; int y = 20; printf("%d,%d\n", x, y); //swap_1(&amp;x, &amp;y); //a成了x的别名 swap_2(x, y); printf("%d,%d\n", x, y); system("pause");&#125;*//*struct Teacher&#123; char* name; int age;&#125;;void myprint(Teacher &amp;t)&#123; cout &lt;&lt; t.name &lt;&lt; "," &lt;&lt; t.age &lt;&lt; endl;&#125;void myprint2(Teacher *t)&#123; cout &lt;&lt; t-&gt;name &lt;&lt; "," &lt;&lt; t-&gt;age &lt;&lt; endl;&#125;//引用的主要功能：作为函数的参数或返回值void main()&#123; Teacher t; t.name = "hzh"; t.age = 24; myprint(t); myprint2(&amp;t); system("pause");&#125;*//*//指针的引用，代替二级指针struct Teacher&#123; char* name; int age;&#125;;void getTeacher(Teacher **p)&#123; Teacher *tmp = (Teacher*)malloc(sizeof(Teacher)); tmp-&gt;age = 20; *p = tmp;&#125;//指针的引用，代替二级指针void getTeacher(Teacher* &amp;p)&#123; p = (Teacher*)malloc(sizeof(Teacher)); p-&gt;age = 20;&#125;void main()&#123; Teacher *t = NULL; //getTeacher(&amp;t); getTeacher(t); system("pause");&#125;*///指针常量与常量指针/*void main()&#123; //指针常量，指针的常量，不改变地址的指针，但是可以修改它指向的内容 int a = 2, b = 3; int *const p1 = &amp;a; //p1 = &amp;b; //NO *p1 = 4; //常量指针，指向常量的指针，内容不能修改 const int *p2 = &amp;a; p2 = &amp;b; //*p2 = 4; //NO&#125;*///1.单纯给变量取别名没有任何意义，作为函数参数传递，能保证参数传递过程中不产生副本//2.引用可以直接操作变量，指针要通过取值(*p),间接操作变量，指针的可读性差/*//常引用类似于java中finalvoid myprintf(const int &amp;a)&#123; cout &lt;&lt; a &lt;&lt; endl;&#125;void main()&#123; //const int a; //引用必须要有值，不能为空 //int &amp;a = NULL; //常引用 int a = 10, b = 9; const int &amp;c = a; //字面量 const int &amp;d = 70; //c = b; myprintf(c); system("pause");&#125;*///引用的大小/*struct Teacher&#123; char name[20]; int age;&#125;;void main()&#123; Teacher t; Teacher &amp;t1 = t; Teacher *p = &amp;t; cout &lt;&lt; sizeof(t1) &lt;&lt; endl; cout &lt;&lt; sizeof(p) &lt;&lt; endl; //所有指针都是4字节大小 system("pause");&#125;*//*struct Teacher&#123; char name[20]; int age;&#125;;void myprint(Teacher *t)&#123; cout &lt;&lt; t-&gt;name &lt;&lt; "," &lt;&lt; t-&gt;age &lt;&lt; endl;&#125;void myprint2(Teacher &amp;t)&#123; cout &lt;&lt; t.name &lt;&lt; "," &lt;&lt; t.age &lt;&lt; endl;&#125;void main()&#123; Teacher t; Teacher *p = NULL; //报错，防止不报错，进行非空判断 myprint(p); //引用不能为空，没法传进去 Teacher &amp;t2 = NULL; myprint2(t2); system("pause");&#125;*///函数默认参数/*void myprint(int x,int y = 9,int z = 10)&#123; cout &lt;&lt; x &lt;&lt; endl;&#125;//重载void myprint(int x, int y)&#123; cout &lt;&lt; x &lt;&lt; endl;&#125;void main()&#123; myprint(20); system("pause");&#125;*///可变参数//int.../*void func(int i,...)&#123; //可变参数指针 va_list args_p; //开始读取可变参数，i是最后一个固定参数 va_start(args_p, i); int a = va_arg(args_p, int); char b = va_arg(args_p, char); int c = va_arg(args_p, int); cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; endl; //结束 va_end(args_p);&#125;void main()&#123; func(9,20,'b',30); system("pause");&#125;*///循环读取void func(int i, ...)&#123; //可变参数指针 va_list args_p; //开始读取可变参数，i是最后一个固定参数 va_start(args_p, i); int value = 0; while (1)&#123; value = va_arg(args_p, int); if (value &lt;= 0)&#123; break; &#125; cout &lt;&lt; value &lt;&lt; endl; &#125; //结束 va_end(args_p);&#125;void main()&#123; func(9, 20, 40, 30); system("pause");&#125;]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_C++</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造函数_析构函数_拷贝构造函数]]></title>
    <url>%2F2019%2F09%2F27%2F08_26_C%2B%2B%2F</url>
    <content type="text"><![CDATA[01.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212//C++类的普遍写法/*#include "MyTeacher.h"void main()&#123; MyTeacher t1; t1.name = "Jack"; t1.age = 20; cout &lt;&lt; t1.getName() &lt;&lt; endl; system("pause");&#125;*///构造函数、析构函数、拷贝构造函数/*class Teacher&#123;private: char* name; int age;public: //无参构造函数(写了，就会覆盖默认的无参构造函数) Teacher()&#123; cout &lt;&lt; "无参构造函数" &lt;&lt; endl; &#125; //有参构造函数会覆盖默认的构造函数 Teacher(char *name,int age)&#123; this-&gt;name = name; this-&gt;age = age; cout &lt;&lt; "有参构造函数" &lt;&lt; endl; &#125;&#125;;void main()&#123; //Teacher t1; Teacher t2("yuehan",20); //另外一种调用方式 Teacher t3 = Teacher("jack", 21); system("pause");&#125;*///析构函数/*class Teacher&#123;private: char* name; int age;public: //无参构造函数赋默认值 Teacher()&#123; this-&gt;name = (char*)malloc(100); strcpy(name, "jack walson"); age = 20; cout &lt;&lt; "无参构造函数" &lt;&lt; endl; &#125; //析构函数 //当对象要被系统释放时，析构函数被调用 //作用：善后处理 ~Teacher()&#123; cout &lt;&lt; "析构函数" &lt;&lt; endl; //释放内存 free(this-&gt;name); &#125;&#125;;void func()&#123; Teacher t1;&#125;void main()&#123; func(); system("pause");&#125;*///拷贝构造函数class Teacher&#123;private: char* name; int age;public: Teacher(char *name, int age)&#123; this-&gt;name = name; this-&gt;age = age; cout &lt;&lt; "有参构造函数" &lt;&lt; endl; &#125; //拷贝构造函数(值拷贝) //默认拷贝构造函数，就是值拷贝 Teacher(const Teacher &amp;obj)&#123; this-&gt;name = obj.name; this-&gt;age = obj.age; cout &lt;&lt; "拷贝构造函数" &lt;&lt; endl; &#125; void myprint()&#123; cout &lt;&lt; name &lt;&lt; "," &lt;&lt; age &lt;&lt; endl; &#125;&#125;;void func1(Teacher t)&#123; t.myprint();&#125;Teacher func2(Teacher t)&#123; t.myprint(); return t;&#125;void main()&#123; Teacher t1("rose",20); //拷贝构造函数被调用的场景： //1.声明时赋值 //Teacher t2 = t1; //t2.myprint(); //2.作为参数传入，实参给形参赋值 func1(t1); //3.作为函数返回值返回，给变量初始化赋值 Teacher t3 = func2(t1); //这种情况下拷贝构造函数不会被调用 Teacher t4("rose", 20); Teacher t5("jack", 23); t4 = t5; system("pause");&#125;//浅拷贝(值拷贝)问题/*class Teacher&#123;private: char* name; int age;public: Teacher(char *name, int age)&#123; this-&gt;name = (char*)malloc(100); strcpy(this-&gt;name, name); this-&gt;age = age; cout &lt;&lt; "有参构造函数" &lt;&lt; endl; &#125; ~Teacher()&#123; cout &lt;&lt; "析构函数" &lt;&lt; endl; //释放内存 free(this-&gt;name); &#125; void myprint()&#123; cout &lt;&lt; name &lt;&lt; "," &lt;&lt; age &lt;&lt; endl; &#125;&#125;;void main()&#123; Teacher t1("rose", 20); Teacher t2 = t1; t2.myprint(); system("pause");&#125;*///浅拷贝(值拷贝)，拷贝的是指针的地址//深拷贝，拷贝的是指针指向的数据内容//深拷贝/*class Teacher&#123;private: char* name; int age;public: Teacher(char *name, int age)&#123; int len = strlen(name); this-&gt;name = (char*)malloc(len + 1); strcpy(this-&gt;name, name); this-&gt;age = age; cout &lt;&lt; "有参构造函数" &lt;&lt; endl; &#125; ~Teacher()&#123; cout &lt;&lt; "析构函数" &lt;&lt; endl; //释放内存 free(this-&gt;name); &#125; //深拷贝 Teacher(const Teacher &amp;obj)&#123; //复制name属性 int len = strlen(obj.name); this-&gt;name = (char*)malloc(len + 1);//+1 加一个结束符'\0' strcpy(this-&gt;name, obj.name); this-&gt;age = obj.age; cout &lt;&lt; "深拷贝"&lt;&lt;endl; &#125; void myprint()&#123; cout &lt;&lt; name &lt;&lt; "," &lt;&lt; age &lt;&lt; endl; &#125;&#125;;void func()&#123; Teacher t1("rose", 20); Teacher t2 = t1; t2.myprint();&#125;void main()&#123; func(); system("pause");&#125;*/]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_C++</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse下NDK开发]]></title>
    <url>%2F2019%2F09%2F27%2F08_17_JNI_02%2F</url>
    <content type="text"><![CDATA[1234567891011121314Eclipse NDK开发流程1.编写Java层Native方法2.javah命令生成头文件3.创建jni目录4.添加本地支持add native support5.实现头文件中定义的函数6.编译生成.so动态库7.加载动态库J:\dev\NDK\android-ndk-r9\toolchains\arm-linux-androideabi-4.6\prebuilt\windows-x86_64\lib\gcc\arm-linux-androideabi\4.6\includeJ:\dev\NDK\android-ndk-r9\toolchains\arm-linux-androideabi-4.6\prebuilt\windows-x86_64\lib\gcc\arm-linux-androideabi\4.6\include-fixedJ:\dev\NDK\android-ndk-r9\platforms\android-18\arch-arm\usr\include Android.mk12345678LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := ndk_file_cryptLOCAL_SRC_FILES := ndk_file_crypt.cinclude $(BUILD_SHARED_LIBRARY) ndk_file_crypt.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include "com_hzh_ndk_file_crypt_Cryptor.h"#include &lt;stdio.h&gt;#include &lt;string.h&gt;char password[] = "mynameisjason888";//加密JNIEXPORT void JNICALL Java_com_hzh_ndk_1file_1crypt_Cryptor_crypt (JNIEnv *env, jclass jcls, jstring normal_path_jstr,jstring crypt_path_jstr)&#123; //jstring -&gt; char* const char *normal_path = (*env)-&gt;GetStringUTFChars(env,normal_path_jstr,NULL); const char *crypt_path = (*env)-&gt;GetStringUTFChars(env, crypt_path_jstr, NULL); //打开文件 FILE *normal_fp = fopen(normal_path, "rb"); FILE *encrypt_fp = fopen(crypt_path, "wb"); //一次读取一个字符 int ch; int i = 0;//循环使用密码中的字母进行异或运算 int pwd_len = strlen(password);//密码长度 while ((ch = fgetc(normal_fp)) != EOF)&#123; //END of File //写入(异或运算) fputc(ch ^ password[i % pwd_len], encrypt_fp); i++; &#125; //关闭 fclose(encrypt_fp); fclose(normal_fp);&#125;//解密JNIEXPORT void JNICALL Java_com_hzh_ndk_1file_1crypt_Cryptor_decrypt (JNIEnv *env, jclass jcls, jstring crypt_path_jstr,jstring decrypt_path_jstr)&#123; const char *decrypt_path = (*env)-&gt;GetStringUTFChars(env,decrypt_path_jstr,NULL); const char *crypt_path = (*env)-&gt;GetStringUTFChars(env, crypt_path_jstr, NULL); //打开文件 FILE *encrypt_fp = fopen(crypt_path, "rb"); FILE *decrypt_fp = fopen(decrypt_path, "wb"); //一次读取一个字符 int ch; int i = 0;//循环使用密码中的字母进行异或运算 int pwd_len = strlen(password);//密码长度 while ((ch = fgetc(encrypt_fp)) != EOF)&#123; //END of File //写入(异或运算) fputc(ch ^ password[i % pwd_len], decrypt_fp); i++; &#125; //关闭 fclose(encrypt_fp); fclose(decrypt_fp);&#125; Cryptor.java1234567891011121314151617181920package com.hzh.ndk_file_crypt;public class Cryptor &#123; static &#123; System.loadLibrary("ndk_file_crypt"); &#125; /** * 加密 * @param path */ public native static void crypt(String normal_path,String crypt_path); /** * 解密 * @param path */ public native static void decrypt(String crypt_path,String decrypt_path);&#125;]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_JNI</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_JNI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造函数属性初始化_静态成员_this指针]]></title>
    <url>%2F2019%2F09%2F27%2F08_29_C%2B%2B_01%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233//构造函数的属性初始化列表/*class Teacher&#123;private: char* name;public: Teacher(char* name)&#123; this-&gt;name = name; cout &lt;&lt; "Teacher有参构造函数" &lt;&lt; endl; &#125; ~Teacher()&#123; cout &lt;&lt; "Teacher析构函数" &lt;&lt; endl; &#125; char* getName()&#123; return this-&gt;name; &#125;&#125;;class Student&#123;private: int id; //属性对象 //Teacher t = Teacher("miss cang"); Teacher t1; Teacher t2;public: Student(int id, char* t1_n,char* t2_n) : t1(t1_n),t2(t2_n)&#123; this-&gt;id = id; cout &lt;&lt; "Student有参构造函数" &lt;&lt; endl; &#125; void myprint()&#123; cout &lt;&lt; id &lt;&lt; "," &lt;&lt; t1.getName() &lt;&lt; endl; &#125; ~Student()&#123; cout &lt;&lt; "Student析构函数" &lt;&lt; endl; &#125;&#125;;void func()&#123; Student s1(10, "miss bo", "miss liu"); //Student s2(20, "miss cang", "jason"); s1.myprint(); //s2.myprint();&#125;void main()&#123; func(); system("pause");&#125;*///C++ 通过new(delete)动态内存分配//C malloc(free)/*class Teacher&#123;private: char* name;public: Teacher(char* name)&#123; this-&gt;name = name; cout &lt;&lt; "Teacher有参构造函数" &lt;&lt; endl; &#125; ~Teacher()&#123; cout &lt;&lt; "Teacher析构函数" &lt;&lt; endl; &#125; void setName(char* name)&#123; this-&gt;name = name; &#125; char* getName()&#123; return this-&gt;name; &#125;&#125;;void func()&#123; //C++ //会调用构造和析构函数 //Teacher *t1 = new Teacher("jack"); //cout &lt;&lt; t1-&gt;getName() &lt;&lt; endl; //释放 //delete t1; //C //Teacher *t2 = (Teacher*)malloc(sizeof(Teacher)); //t2-&gt;setName("jack"); //free(t2);&#125;void main()&#123; func(); //数组类型 //C //int *p1 = (int*)malloc(sizeof(int)* 10); //p1[0] = 9; //free(p1); //C++ int *p2 = new int[10]; p2[0] = 2; //释放数组 [] delete[] p2; system("pause");&#125;*///static 静态属性和方法/*class Teacher&#123;public: char* name; //计数器 static int total;public: Teacher(char* name)&#123; this-&gt;name = name; cout &lt;&lt; "Teacher有参构造函数" &lt;&lt; endl; &#125; ~Teacher()&#123; cout &lt;&lt; "Teacher析构函数" &lt;&lt; endl; &#125; void setName(char* name)&#123; this-&gt;name = name; &#125; char* getName()&#123; return this-&gt;name; &#125; //计数，静态函数 static void count()&#123; total++; cout &lt;&lt; total &lt;&lt; endl; &#125;&#125;;//静态属性初始化赋值int Teacher::total = 9;void main()&#123; Teacher::total++; cout &lt;&lt; Teacher::total &lt;&lt; endl; //直接通过类名访问 Teacher::count(); //也可以通过对象名访问 Teacher t1("yuehang"); t1.count(); system("pause");&#125;*///类的大小/*void myprintf()&#123; cout &lt;&lt; "打印" &lt;&lt; endl;&#125;class A&#123;public: int i; int j; int k; static int m;&#125;;class B&#123;public: int i; int j; int k; //void(*myprintf)() = myprintf; void myprintf()&#123; //在程序代码区中，不计算大小 cout &lt;&lt; "打印" &lt;&lt; endl; &#125;&#125;;void main()&#123; cout &lt;&lt; sizeof(A) &lt;&lt; endl; cout &lt;&lt; sizeof(B) &lt;&lt; endl; //C/C++ 内存分区：栈、堆、全局(静态、全局)、常量区(字符串)、程序代码区 //普通属性与结构体相同的内存布局，普通属性才算做类的大小 system("pause");&#125;*///this，当前对象的指针//函数是共享的，必须要有能够标识当前对象是谁的办法/*class Teacher&#123;private: char* name; int age;public: Teacher(char* name,int age)&#123; this-&gt;name = name; this-&gt;age = age; cout &lt;&lt; "Teacher有参构造函数" &lt;&lt; endl; &#125; ~Teacher()&#123; cout &lt;&lt; "Teacher析构函数" &lt;&lt; endl; &#125; //常函数，修饰的是this //既不能改变指针的值，又不能改变指针指向的内容 //const Teacher* const this void myprint() const&#123; printf("%#x\n", this); //改变属性的值 //this-&gt;name = "yuehan"; //改变this指针的值 //this = (Teacher*)0x00009; cout &lt;&lt; this-&gt;name &lt;&lt; "," &lt;&lt; this-&gt;age &lt;&lt; endl; &#125; void myprint2()&#123; cout &lt;&lt; this-&gt;name &lt;&lt; "," &lt;&lt; this-&gt;age &lt;&lt; endl; //this = (Teacher*)0x9000; this指针是常量指针 &#125;&#125;;void main()&#123; Teacher t1("jack", 20); const Teacher t2("rose", 18); //t2.myprint2(); 常量对象只能调用常量函数，不能调用非常量函数 //常函数，当前对象不能被修改，防止数据成员被非法访问 printf("%#x\n", &amp;t1); t1.myprint(); printf("%#x\n", &amp;t2); t2.myprint(); system("pause");&#125;*/]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_C++</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[友元函数_运算符重载]]></title>
    <url>%2F2019%2F09%2F27%2F08_29_C%2B%2B_02%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139//友元函数/*class A&#123; //友元函数 friend void modify_i(A* p, int a);private: int i;public: A(int i)&#123; this-&gt;i = i; &#125; void myprint()&#123; cout &lt;&lt; i &lt;&lt; endl; &#125;&#125;;//友元函数的实现，在友元函数中可以访问私有的属性void modify_i(A* p, int a)&#123; p-&gt;i = a;&#125;void main()&#123; A* a = new A(10); a-&gt;myprint(); modify_i(a,20); a-&gt;myprint(); system("pause");&#125;*///友元类/*class A&#123; //友元类 friend class B;private: int i;public: A(int i)&#123; this-&gt;i = i; &#125; void myprint()&#123; cout &lt;&lt; i &lt;&lt; endl; &#125;&#125;;class B&#123;public: //B这个友元类可以访问A类的任何成员 void accessAny()&#123; a.i = 30; &#125;private: A a;&#125;;*///运算符重载/*class Point&#123;public: int x; int y;public: Point(int x = 0,int y = 0)&#123; this-&gt;x = x; this-&gt;y = y; &#125; //成员函数，运算符重载 Point operator+(Point &amp;p2)&#123; Point tmp(this-&gt;x + p2.x, this-&gt;y + p2.y); return tmp; &#125; void myprint()&#123; cout &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; endl; &#125;&#125;;//重载+号//Point operator+(Point &amp;p1, Point &amp;p2)&#123;// Point tmp(p1.x + p2.x, p1.y + p2.y);// return tmp;//&#125;//重载-号Point operator-(Point &amp;p1, Point &amp;p2)&#123; Point tmp(p1.x - p2.x, p1.y - p2.y); return tmp;&#125;void main()&#123; Point p1(10, 20); Point p2(20, 10); //运算符的重载，本质还是函数调用 //p1.operator+(p2) Point p3 = p1 + p2; p3.myprint(); system("pause");&#125;*///当属性私有时，通过友元函数完成运算符重载class Point&#123; friend Point operator+(Point &amp;p1, Point &amp;p2);private: int x; int y;public: Point(int x = 0, int y = 0)&#123; this-&gt;x = x; this-&gt;y = y; &#125; void myprint()&#123; cout &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; endl; &#125;&#125;;Point operator+(Point &amp;p1, Point &amp;p2)&#123; Point tmp(p1.x + p2.x, p1.y + p2.y); return tmp;&#125;void main()&#123; Point p1(10, 20); Point p2(20, 10); //运算符的重载，本质还是函数调用 //p1.operator+(p2) Point p3 = p1 + p2; p3.myprint(); system("pause");&#125;]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_C++</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承_继承的二义性]]></title>
    <url>%2F2019%2F09%2F27%2F08_31_C%2B%2B_01%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294#include&lt;iostream&gt;using namespace std;//继承//代码的重用性//人类/*class Human&#123;public: void say()&#123; cout &lt;&lt; "说话" &lt;&lt; endl; &#125;protected: char* name; int age;&#125;;//男人class Man : public Human&#123;public: //泡妞 void chasing()&#123; cout &lt;&lt; "泡妞" &lt;&lt; endl; &#125;private: char* brother;&#125;;void work(Human &amp;h)&#123; h.say();&#125;void main()&#123; Man m1; m1.say(); //父类类型的引用或指针 Human* h_p = &amp;m1; h_p-&gt;say(); Human &amp;h1 = m1; h1.say(); //子类对象初始化父类类型的对象 Human h2 = m1; system("pause");&#125;*///向父类构造方法传参/*class Human&#123;public: Human(char* name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; void say()&#123; cout &lt;&lt; "说话" &lt;&lt; endl; &#125;protected: char* name; int age;&#125;;//男人class Man : public Human&#123;public: //给父类构造函数传参，同时给属性对象赋值 Man(char *brother, char *s_name, int s_age, char *h_name, int h_age) : Human(s_name, s_age),h(h_name,h_age)&#123; this-&gt;brother = brother; &#125; //泡妞 void chasing()&#123; cout &lt;&lt; "泡妞" &lt;&lt; endl; &#125;private: char* brother; Human h;&#125;;void main()&#123; Man m1("danny","jack",18,"jason",18); system("pause");&#125;*///构造函数与析构函数调用的顺序/*class Human&#123;public: Human(char* name, int age)&#123; this-&gt;name = name; this-&gt;age = age; cout &lt;&lt; "Human 构造方法" &lt;&lt; endl; &#125; ~Human()&#123; cout &lt;&lt; "Human 析构函数" &lt;&lt; endl; &#125; void say()&#123; cout &lt;&lt; "说话" &lt;&lt; endl; &#125;protected: char* name; int age;&#125;;//男人class Man : public Human&#123;public: //给父类构造函数传参，同时给属性对象赋值 Man(char *brother, char *s_name, int s_age) : Human(s_name, s_age)&#123; this-&gt;brother = brother; cout &lt;&lt; "Man 构造方法" &lt;&lt; endl; &#125; ~Man()&#123; cout &lt;&lt; "Man 析构函数" &lt;&lt; endl; &#125; //泡妞 void chasing()&#123; cout &lt;&lt; "泡妞" &lt;&lt; endl; &#125;private: char* brother;&#125;;void func()&#123; //父类构造函数先调用 //子类析构函数先调用 Man m1("danny", "jack", 18);&#125;void main()&#123; func(); system("pause");&#125;*///调用父类的重名函数//子类对象调用父类的成员/*class Human&#123;public: Human(char* name, int age)&#123; this-&gt;name = name; this-&gt;age = age; cout &lt;&lt; "Human 构造方法" &lt;&lt; endl; &#125; ~Human()&#123; cout &lt;&lt; "Human 析构函数" &lt;&lt; endl; &#125; void say()&#123; cout &lt;&lt; "说话" &lt;&lt; endl; &#125;public: char* name; int age;&#125;;//男人class Man : public Human&#123;public: //给父类构造函数传参，同时给属性对象赋值 Man(char *brother, char *s_name, int s_age) : Human(s_name, s_age)&#123; this-&gt;brother = brother; cout &lt;&lt; "Man 构造方法" &lt;&lt; endl; &#125; ~Man()&#123; cout &lt;&lt; "Man 析构函数" &lt;&lt; endl; &#125; //泡妞 void chasing()&#123; cout &lt;&lt; "泡妞" &lt;&lt; endl; &#125; //是覆盖，并非多态 void say()&#123; cout &lt;&lt; "男人喜欢装逼" &lt;&lt; endl; &#125;private: char* brother;&#125;;void main()&#123; Man m1("alan","john",18); m1.say(); m1.Human::say(); m1.Human::age = 10; Human h1 = m1; h1.say(); system("pause");&#125;*///多继承/*//人class Person&#123;&#125;;//公民class Citizen&#123;&#125;;//学生，既是人，又是公民class Student : public Person, public Citizen&#123;&#125;;*///继承的访问修饰//基类中 继承方式 子类中//public &amp; public继承 = &gt; public//public &amp; protected继承 = &gt; protected//public &amp; private继承 = &gt; privated////protected &amp; public继承 = &gt; protected//protected &amp; protected继承 = &gt; protected//protected &amp; private继承 = &gt; private////private &amp; public继承 = &gt; 子类无权访问//private &amp; protected继承 = &gt; 子类无权访问//private &amp; private继承 = &gt; 子类无权访问/*class Human&#123;public: void say()&#123; cout &lt;&lt; "说话" &lt;&lt; endl; &#125;protected: char* name; int age;&#125;;//男人class Man : protected Human&#123;public: //泡妞 void chasing()&#123; cout &lt;&lt; "泡妞" &lt;&lt; endl; &#125;private: char* brother;&#125;;void main()&#123; Man m1; m1.say(); system("pause");&#125;*///继承的二义性//虚继承，不同路径继承来的同名成员只有一份拷贝，解决不明确的问题/*class A&#123;public: char* name;&#125;;class A1 : virtual public A&#123;&#125;;class A2 : virtual public A&#123;&#125;;class B : public A1, public A2&#123;&#125;;void main()&#123; B b; b.name = "jason"; //指定父类显示调用 //b.A1::name = "jason"; //b.A2::name = "jason"; system("pause");&#125;*/]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_C++</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多态与模板函数]]></title>
    <url>%2F2019%2F09%2F27%2F08_31_C%2B%2B_02%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//虚函数/*//多态(程序的扩展性)//动态多态：程序运行过程中，决定哪一个函数被调用(重写)//静态多态：重载//发生多态的条件://1.继承//2.父类的引用或者指针指向子类的对象//3.函数的重写#include "Plane.h"#include "Jet.h"#include "Copter.h"//业务函数void bizPlay(Plane &amp;p)&#123; p.fly(); p.land();&#125;void main()&#123; Plane p1; bizPlay(p1); Jet p2; bizPlay(p2); Copter p3; bizPlay(p3); system("pause");&#125;*///纯虚函数(抽象类)//1.当一个类具有一个纯虚函数，这个类就是抽象类//2.抽象类不能实例化对象//3.子类继承抽象类，必须要实现纯虚函数，如果没有，子类也是抽象类//抽象类的作用：为了继承约束，根本不知道未来的实现//形状/*class Shape&#123;public: //纯虚函数 virtual void sayArea() = 0; void print()&#123; cout &lt;&lt; "hi" &lt;&lt; endl; &#125;&#125;;//圆class Circle : public Shape&#123;public: Circle(int r)&#123; this-&gt;r = r; &#125; void sayArea()&#123; cout &lt;&lt; "圆的面积:" &lt;&lt; (3.14 * r * r) &lt;&lt; endl; &#125;private: int r;&#125;;void main()&#123; Shape s; Circle c(10); system("pause");&#125;*///接口(只是逻辑上的划分，语法上跟抽象类的写法没有区别)//可以当做一个接口/*class Drawble&#123; virtual void draw() = 0;&#125;;void main()&#123; system("pause");&#125;*///模板函数(泛型)/*void myswap(int &amp;a, int &amp;b)&#123; int tmp = 0; tmp = a; a = b; b = tmp;&#125;void myswap(char &amp;a, char &amp;b)&#123; char tmp = 0; tmp = a; a = b; b = tmp;&#125;*///发现：这两个函数业务逻辑一样，数据类型不一样template&lt;typename T&gt;void myswap(T &amp;a, T &amp;b)&#123; T tmp = 0; tmp = a; a = b; b = tmp;&#125;void main()&#123; //根据实际类型，自动推导 int a = 10, b = 20; myswap&lt;int&gt;(a,b); cout &lt;&lt; a &lt;&lt; "," &lt;&lt; b &lt;&lt; endl; char x = 'v', y = 'w'; myswap(x, y); cout &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; endl; system("pause");&#125; Plane.h12345678#pragma once//普通飞机class Plane&#123;public: virtual void fly(); virtual void land();&#125;; Plane.cpp1234567891011#include"Plane.h"#include&lt;iostream&gt;using namespace std;void Plane::fly()&#123; cout &lt;&lt; "起飞" &lt;&lt; endl;&#125;void Plane::land()&#123; cout &lt;&lt; "着陆" &lt;&lt; endl;&#125; Jet.h12345678910#pragma once#include"Plane.h"//直升飞机class Jet : public Plane&#123;public: virtual void fly(); virtual void land();&#125;; Jet.cpp123456789101112#include"Jet.h"#include&lt;iostream&gt;using namespace std;void Jet::fly()&#123; cout &lt;&lt; "直升飞机在原地起飞..." &lt;&lt; endl;&#125;void Jet::land()&#123; cout &lt;&lt; "直升飞机着陆..." &lt;&lt; endl;&#125; Copter.h12345678910#pragma once#include"Plane.h"//喷气式飞机class Copter : public Plane&#123;public: virtual void fly(); virtual void land();&#125;; Copter.cpp123456789101112#include"Copter.h"#include&lt;iostream&gt;using namespace std;void Copter::fly()&#123; cout &lt;&lt; "喷气式飞机在跑道上起飞..." &lt;&lt; endl;&#125;void Copter::land()&#123; cout &lt;&lt; "喷气式飞机在跑道上着陆..." &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_C++</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fmod-QQ变声特效]]></title>
    <url>%2F2019%2F09%2F27%2F09_02_C%2B%2B%2F</url>
    <content type="text"><![CDATA[app下build.gradle12345678910android&#123; ... externalNativeBuild &#123; cmake &#123; cppFlags "" abiFilters 'armeabi', 'armeabi-v7a', "x86", "arm64-v8a" arguments '-DANDROID_STL=gnustl_static' //支持C++异常处理，标准模板库 &#125; &#125;&#125; CMakeLists.txt123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# For more information about using CMake with Android Studio, read the# documentation: https://d.android.com/studio/projects/add-native-code.html# Sets the minimum version of CMake required to build the native library.cmake_minimum_required(VERSION 3.4.1)# Creates and names a library, sets it as either STATIC# or SHARED, and provides the relative paths to its source code.# You can define multiple libraries, and CMake builds them for you.# Gradle automatically packages shared libraries with your APK.file(GLOB native_srcs "src/main/cpp/*.cpp")set(my_lib_path $&#123;CMAKE_SOURCE_DIR&#125;/libs)set(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;/../jniLibs/$&#123;ANDROID_ABI&#125;)# 添加三方的so库add_library(libfmod SHARED IMPORTED ) # 指名第三方库的绝对路径 set_target_properties( libfmod PROPERTIES IMPORTED_LOCATION $&#123;my_lib_path&#125;/$&#123;ANDROID_ABI&#125;/libfmod.so )add_library(libfmodL SHARED IMPORTED) set_target_properties(libfmodL PROPERTIES IMPORTED_LOCATION $&#123;my_lib_path&#125;/$&#123;ANDROID_ABI&#125;/libfmodL.so)add_library( # Sets the name of the library. qq_voicer # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). $&#123;native_srcs&#125;)# Searches for a specified prebuilt library and stores the path as a# variable. Because CMake includes system libraries in the search path by# default, you only need to specify the name of the public NDK library# you want to add. CMake verifies that the library exists before# completing its build.find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log )# Specifies libraries CMake should link to your target library. You# can link multiple libraries, such as libraries you define in this# build script, prebuilt third-party libraries, or system libraries.target_link_libraries( # Specifies the target library. qq_voicer libfmod libfmodL # Links the target library to the log library # included in the NDK. $&#123;log-lib&#125; ) QQActivity.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.hzh.qq_voicer_change;import android.content.pm.PackageManager;import android.os.Build;import android.os.Bundle;import android.os.Environment;import android.support.v7.app.AppCompatActivity;import android.view.View;import org.fmod.FMOD;import java.io.File;public class QQActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_qq); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; String[] perms = &#123; "android.permission.RECORD_AUDIO", "android.permission.WRITE_EXTERNAL_STORAGE" &#125;; if (checkSelfPermission(perms[0]) == PackageManager.PERMISSION_DENIED || checkSelfPermission(perms[1]) == PackageManager.PERMISSION_DENIED) &#123; requestPermissions(perms, 200); &#125; &#125; FMOD.init(this); &#125; @Override protected void onDestroy() &#123; FMOD.close(); super.onDestroy(); &#125; public void mFix(View view) &#123; String path = Environment.getExternalStorageDirectory().getAbsolutePath() + File.separatorChar + "Baidu-TTS.mp3"; switch (view.getId())&#123; case R.id.btn_normal: EffectUtils.fix(path,EffectUtils.MODE_NORMAL); break; case R.id.btn_luoli: EffectUtils.fix(path,EffectUtils.MODE_LUOLI); break; case R.id.btn_dashu: EffectUtils.fix(path,EffectUtils.MODE_DASHU); break; case R.id.btn_jingsong: EffectUtils.fix(path,EffectUtils.MODE_JINGSONG); break; case R.id.btn_gaoguai: EffectUtils.fix(path,EffectUtils.MODE_GAOGUAI); break; case R.id.btn_kongling: EffectUtils.fix(path,EffectUtils.MODE_KONGLING); break; &#125; &#125;&#125; EffectUtils.java1234567891011121314151617181920212223242526package com.hzh.qq_voicer_change;public class EffectUtils &#123; //音效的类型 public static final int MODE_NORMAL = 0; public static final int MODE_LUOLI = 1; public static final int MODE_DASHU = 2; public static final int MODE_JINGSONG = 3; public static final int MODE_GAOGUAI = 4; public static final int MODE_KONGLING = 5; /** * 音效处理 * @param path * @param type */ public native static void fix(String path,int type); static &#123; System.loadLibrary("fmodL"); System.loadLibrary("fmod"); System.loadLibrary("qq_voicer"); &#125;&#125; com_hzh_qq_voicer_change_EffectUtils.h123456789101112131415161718192021/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class com_hzh_qq_voicer_change_EffectUtils */#ifndef _Included_com_hzh_qq_voicer_change_EffectUtils#define _Included_com_hzh_qq_voicer_change_EffectUtils#ifdef __cplusplusextern "C" &#123;#endif/* * Class: com_hzh_qq_voicer_change_EffectUtils * Method: fix * Signature: (Ljava/lang/String;I)V */JNIEXPORT void JNICALL Java_com_hzh_qq_1voicer_1change_EffectUtils_fix (JNIEnv *, jclass, jstring, jint);#ifdef __cplusplus&#125;#endif#endif effect_fix.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120//// Created by Administrator on 2019/1/10 0010.//#include "inc/fmod.hpp"#include &lt;unistd.h&gt;#include "com_hzh_qq_voicer_change_EffectUtils.h"#include &lt;android/log.h&gt;#define LOGI(FORMAT,...) __android_log_print(ANDROID_LOG_INFO,"hzh",FORMAT,##__VA_ARGS__)#define LOGE(FORMAT,...) __android_log_print(ANDROID_LOG_ERROR,"hzh",FORMAT,##__VA_ARGS__)#define MODE_NORMAL 0#define MODE_LUOLI 1#define MODE_DASHU 2#define MODE_JINGSONG 3#define MODE_GAOGUAI 4#define MODE_KONGLING 5using namespace FMOD;JNIEXPORT void JNICALL Java_com_hzh_qq_1voicer_1change_EffectUtils_fix (JNIEnv *env, jclass jcls, jstring path_jstr, jint type)&#123; System *system; Sound *sound; Channel *channel; DSP *dsp; bool playing = true; float frequency = 0; const char* path_cstr = env-&gt;GetStringUTFChars(path_jstr,NULL); try &#123; //初始化 System_Create(&amp;system); system-&gt;init(32, FMOD_INIT_NORMAL, NULL); //创建声音 system-&gt;createSound(path_cstr, FMOD_DEFAULT, 0, &amp;sound); switch (type)&#123; case MODE_NORMAL: //原生播放 system-&gt;playSound(sound, 0, false, &amp;channel); LOGI("fix normal"); break; case MODE_LUOLI: system-&gt;playSound(sound, 0, false, &amp;channel); //萝莉 //DSP digital signal process(数字信号处理) //FMOD_DSP_TYPE_PITCHSHIFT dsp,提升或者降低音调用的一种音效 system-&gt;createDSPByType(FMOD_DSP_TYPE_PITCHSHIFT,&amp;dsp); //设置音调的参数 dsp-&gt;setParameterFloat(FMOD_DSP_PITCHSHIFT_PITCH,2.0); //添加到channel channel-&gt;addDSP(0,dsp); LOGI("fix luoli"); break; case MODE_DASHU: system-&gt;playSound(sound, 0, false, &amp;channel); //大叔 //DSP digital signal process(数字信号处理) //FMOD_DSP_TYPE_PITCHSHIFT dsp,提升或者降低音调用的一种音效 system-&gt;createDSPByType(FMOD_DSP_TYPE_PITCHSHIFT,&amp;dsp); //设置音调的参数 dsp-&gt;setParameterFloat(FMOD_DSP_PITCHSHIFT_PITCH,0.8); //添加到channel channel-&gt;addDSP(0,dsp); LOGI("fix dashu"); break; case MODE_JINGSONG: system-&gt;playSound(sound, 0, false, &amp;channel); //惊悚 system-&gt;createDSPByType(FMOD_DSP_TYPE_TREMOLO,&amp;dsp); //设置音调的参数 dsp-&gt;setParameterFloat(FMOD_DSP_TREMOLO_SKEW,0.5); //添加到channel channel-&gt;addDSP(0,dsp); LOGI("fix jingsong"); break; case MODE_GAOGUAI: system-&gt;playSound(sound, 0, false, &amp;channel); //搞怪 //提高说话的速度 channel-&gt;getFrequency(&amp;frequency); frequency = frequency * 1.6; channel-&gt;setFrequency(frequency); LOGI("fix gaoguai"); break; case MODE_KONGLING: system-&gt;playSound(sound, 0, false, &amp;channel); //空灵 system-&gt;createDSPByType(FMOD_DSP_TYPE_ECHO,&amp;dsp); dsp-&gt;setParameterFloat(FMOD_DSP_ECHO_DELAY,300); dsp-&gt;setParameterFloat(FMOD_DSP_ECHO_FEEDBACK,20); channel-&gt;addDSP(0,dsp); LOGI("fix kongling"); break; default: break; &#125; &#125;catch (...)&#123; LOGE("%s","发生异常"); goto end; &#125; system-&gt;update(); //释放资源 //单位是微秒 //每秒钟判断下是否在播放 while (playing)&#123; channel-&gt;isPlaying(&amp;playing); usleep(1000 * 1000); &#125; goto end;end: env-&gt;ReleaseStringUTFChars(path_jstr,path_cstr); sound-&gt;release(); system-&gt;close(); system-&gt;release();&#125;]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_C++</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常处理_模板类]]></title>
    <url>%2F2019%2F09%2F27%2F09_05_C%2B%2B%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184//C++异常处理，根据抛出的异常数据类型，进入到相应的catch块中/*void main()&#123; try&#123; int age = 300; if (age &gt; 200)&#123; throw 9.8; &#125; &#125; catch (int a)&#123; cout &lt;&lt; "int异常" &lt;&lt; endl; &#125; catch (char* b)&#123; cout &lt;&lt; b &lt;&lt; endl; &#125; catch (...)&#123; cout &lt;&lt; "未知异常" &lt;&lt; endl; &#125; system("pause");&#125;*///throw抛出函数外/*void mydiv(int a,int b)&#123; if (b == 0)&#123; throw "除数为零"; &#125;&#125;void func()&#123; try&#123; mydiv(8, 0); &#125; catch (char *a)&#123; throw a; &#125;&#125;void main()&#123; try&#123; func(); &#125; catch (char *a)&#123; cout &lt;&lt; a &lt;&lt; endl; &#125; system("pause");&#125;*///抛出对象//异常类/*class MyException&#123;&#125;;void mydiv(int a, int b)&#123; if (b == 0)&#123; //throw MyException(); //throw new MyException; //不要抛出异常指针 throw MyException(); &#125;&#125;void main()&#123; try&#123; mydiv(8,0); &#125; catch (MyException &amp;e2)&#123; //最好用引用，不会产生副本 cout &lt;&lt; "MyException引用" &lt;&lt; endl; &#125; catch (MyException e)&#123; //会产生对象的副本 cout &lt;&lt; "MyException" &lt;&lt; endl; &#125; catch (MyException* e1)&#123; cout &lt;&lt; "MyException指针" &lt;&lt; endl; delete e1; &#125; system("pause");&#125;*///throw 声明函数会抛出的异常类型/*void mydiv(int a, int b) throw (char*,int)&#123; if (b == 0)&#123; throw "除数为零"; &#125;&#125;*///标准异常(类似于JavaNullPointerException)/*class NullPointerException : public exception&#123;public: NullPointerException(char* msg) :exception(msg)&#123; &#125;&#125;;void mydiv(int a, int b) throw (char*, int)&#123; if (b &gt; 10)&#123; throw out_of_range("超出范围"); &#125; else if (b == NULL)&#123; throw NullPointerException("为空"); &#125; else if (b == 0)&#123; throw invalid_argument("参数不合法"); &#125;&#125;void main()&#123; try&#123; mydiv(8, NULL); &#125; catch (out_of_range e1)&#123; cout &lt;&lt; e1.what() &lt;&lt; endl; &#125; catch (NullPointerException &amp;e2)&#123; cout &lt;&lt; e2.what() &lt;&lt; endl; &#125; catch (...)&#123; &#125; system("pause");&#125;*///外部类异常/*class Err&#123;public: class MyException&#123; public:MyException()&#123; &#125; &#125;;&#125;;void mydiv(int a, int b) throw (char*, int)&#123; if (b &gt; 10)&#123; throw Err::MyException(); &#125;&#125;*/template&lt;class T&gt;class A&#123;public: A(T a)&#123; this-&gt;a = a; &#125;protected: T a;&#125;;//普通类继承模板类class B : public A&lt;int&gt;&#123;public: B(int a,int b) : A&lt;int&gt;(a)&#123; this-&gt;b = b; &#125;private: int b;&#125;;//模板类继承模板类template &lt;class T&gt;class C : public A&lt;T&gt;&#123;public: C(T c,T a) : A&lt;T&gt;(a)&#123; this-&gt;c = c; &#125;protected: T c;&#125;;void main()&#123; //实例化模板类对象 A&lt;int&gt; a(6); system("pause");&#125;]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_C++</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++类型转换]]></title>
    <url>%2F2019%2F09%2F27%2F09_07_C%2B%2B_01%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include&lt;iostream&gt;using namespace std;//C++类型转换//static_cast//const_cast//dynamic_cast 子类类型转为父类类型//reinterpret_cast 函数指针转型，不具备移植性//原始类型转换，所有情况都是一种写法，可读性不高，有可能有潜在的风险/*void* func(int type)&#123; switch (type)&#123; case 1:&#123; int i = 9; return &amp;i; &#125; case 2:&#123; char a = 'X'; return &amp;a; &#125; default:&#123; return NULL; &#125; &#125; return NULL;&#125;void func2(char* c_p)&#123; cout &lt;&lt; *c_p &lt;&lt; endl;&#125;void main()&#123; //int i = 0; //自动转换 //double d = i; //double d = 9.5; //int i = d; //int i = 8; //double d = 9.5; //i = static_cast&lt;int&gt;(d); //int i = 9; //int *i_p = &amp;i; //void* -&gt; char* //char* c_p = (char*)func(2); //char* c_p = static_cast&lt;char*&gt;(func(2)); //C++ 意图明显 func2(static_cast&lt;char*&gt;(func(2))); //C func2((char*)(func(2))); system("pause");&#125;*//*void func(const char c[])&#123; //c[1] = 'a'; //通过指针间接赋值 //其他人并不知道，这次转型是为了去常量 //char* c_p = (char*)c; //c_p[1] = 'X'; //提高了可读性 char* c_p = const_cast&lt;char*&gt;(c); c_p[1] = 'Y'; cout &lt;&lt; c &lt;&lt; endl;&#125;void main()&#123; char c[] = "hello"; func(c); system("pause");&#125;*//*class Person&#123;public: virtual void print()&#123; cout &lt;&lt; "人" &lt;&lt; endl; &#125;&#125;;class Man : public Person&#123;public: void print()&#123; cout &lt;&lt; "男人" &lt;&lt; endl; &#125; void chasing()&#123; cout &lt;&lt; "泡妞" &lt;&lt; endl; &#125;&#125;;class Woman : public Person&#123;public: void print()&#123; cout &lt;&lt; "女人" &lt;&lt; endl; &#125; void carebaby()&#123; cout &lt;&lt; "生孩子" &lt;&lt; endl; &#125;&#125;;void func(Person* obj)&#123; //调用子类的特有的函数，转为实际类型 //并不知道转型失败 //Man* m = (Man*)obj; //m-&gt;print(); //转型失败，返回NULL Man *m = dynamic_cast&lt;Man*&gt;(obj); if (m != NULL)&#123; m-&gt;chasing(); &#125; Woman *w = dynamic_cast&lt;Woman*&gt;(obj); if (w != NULL)&#123; w-&gt;carebaby(); &#125;&#125;void main()&#123; Woman w1; Person *p1 = &amp;w1; func(p1); system("pause");&#125;*//*void func1()&#123; cout &lt;&lt; "func1" &lt;&lt; endl;&#125;char* func2()&#123; cout &lt;&lt; "func2" &lt;&lt; endl; return "abc";&#125;typedef void (*f_p)();void main()&#123; //函数指针数组 f_p f_array[6]; //赋值 f_array[0] = func1; //C方式 //f_array[1] = (f_p)func2; //C++方式 f_array[1] = reinterpret_cast&lt;f_p&gt;(func2); f_array[1](); system("pause");&#125;*/]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_C++</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
        <category>Hello</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Hello</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg音频解码及AudioTrack音频播放]]></title>
    <url>%2F2019%2F09%2F27%2F09_23_ffmpeg%2F</url>
    <content type="text"><![CDATA[笔记123456789101112131415161.读取压缩数据时要判断压缩数据的类型while (av_read_frame(pFormatCtx, packet) &gt;= 0)&#123; ... //解码音频类型的packet if (packet-&gt;stream_index == audio_stream_idx)&#123; ... &#125; ...&#125;2.解码每一帧成功时创建了byte数组引用后要释放if (got_frame &gt; 0)&#123; ... (*env)-&gt;DeleteLocalRef(env,audio_sample_array); ...&#125; HzhPlayer.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class HzhPlayer &#123; public native void sound(String input,String output); /** * 创建一个AudioTrack对象，用于播放 * @param nb_channels * @return */ public AudioTrack createAudioTrack(int sampleRateInHz, int nb_channels)&#123; //固定格式的音频码流 int audioFormat = AudioFormat.ENCODING_PCM_16BIT; Log.i("hzh","nb_channels = " + nb_channels); //声道布局 int channelConfig; if (nb_channels == 1)&#123; channelConfig = AudioFormat.CHANNEL_IN_MONO; &#125;else if (nb_channels == 2)&#123; channelConfig = AudioFormat.CHANNEL_OUT_STEREO; &#125;else&#123; channelConfig = AudioFormat.CHANNEL_OUT_STEREO; &#125; int bufferSizeInBytes = AudioTrack.getMinBufferSize(sampleRateInHz,channelConfig,audioFormat); AudioTrack audioTrack = new AudioTrack( AudioManager.STREAM_MUSIC, sampleRateInHz,channelConfig, audioFormat, bufferSizeInBytes,AudioTrack.MODE_STREAM); //播放 //audioTrack.play(); //写入PCM //audioTrack.write(byte[] audioData, int offsetInBytes, int sizeInBytes); return audioTrack; &#125; static &#123; System.loadLibrary("avutil-54"); System.loadLibrary("swresample-1"); System.loadLibrary("avcodec-56"); System.loadLibrary("avformat-56"); System.loadLibrary("swscale-3"); System.loadLibrary("postproc-53"); System.loadLibrary("avfilter-5"); System.loadLibrary("avdevice-56"); System.loadLibrary("audio_player"); &#125;&#125; audio_player.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include "com_hzh_ffmpeg_player_HzhPlayer.h"//封装格式#include "libavformat/avformat.h"//解码#include "libavcodec/avcodec.h"//缩放#include "libswscale/swscale.h"//重采样#include "libswresample/swresample.h"#include "unistd.h"#define MAX_AUDIO_FRAME_SIZE 48000 * 4JNIEXPORT void JNICALL Java_com_hzh_ffmpeg_1player_HzhPlayer_sound (JNIEnv *env, jobject jthiz, jstring input_jstr, jstring output_jstr)&#123; const char *input_cstr = (*env)-&gt;GetStringUTFChars(env, input_jstr, NULL); const char *output_cstr = (*env)-&gt;GetStringUTFChars(env, output_jstr,NULL); //1.注册组件 av_register_all(); AVFormatContext *pFormatCtx = avformat_alloc_context(); //打开音频文件 if (avformat_open_input(&amp;pFormatCtx,input_cstr,NULL,NULL) !=0)&#123; LOGE("%s","无法打开音频文件"); return; &#125; //获取输入文件信息 if(avformat_find_stream_info(pFormatCtx,NULL) &lt; 0)&#123; LOGE("%s","无法获取输入文件信息"); return; &#125; //获取音频流索引位置 int i = 0,audio_stream_idx = -1; for (; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123; if (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO)&#123; audio_stream_idx = i; break; &#125; &#125; //获取解码器 AVCodecContext *codecCtx = pFormatCtx-&gt;streams[audio_stream_idx]-&gt;codec; AVCodec *codec = avcodec_find_decoder(codecCtx-&gt;codec_id); if (codec == NULL)&#123; LOGE("%s","无法获取解码器"); return; &#125; //打开解码器 if (avcodec_open2(codecCtx,codec,NULL) &lt; 0)&#123; LOGE("%s","无法打开解码器"); return; &#125; //压缩数据 AVPacket *packet = av_malloc(sizeof(AVPacket)); //解压缩数据 AVFrame *frame = av_frame_alloc(); //frame-&gt;16bit 44100HZ PCM 统一音频采样格式与采样率 SwrContext *swrCtx = swr_alloc(); //重采样设置参数------------start //输入的采样格式 enum AVSampleFormat in_sample_fmt = codecCtx-&gt;sample_fmt; //输出采样格式16bit PCM enum AVSampleFormat out_sample_fmt = AV_SAMPLE_FMT_S16; //输入采样率 int in_sample_rate = codecCtx-&gt;sample_rate; //输出采样率 int out_sample_rate = in_sample_rate; //获取输入的声道布局 //根据声道个数获取默认的声道布局（2个声道，默认立体声stereo） //av_get_default_channel_layout(codecCtx-&gt;channels); uint64_t in_ch_layout = codecCtx-&gt;channel_layout; //输出的声道布局 uint64_t out_ch_layout = AV_CH_LAYOUT_STEREO; swr_alloc_set_opts(swrCtx, out_ch_layout,out_sample_fmt,out_sample_rate, in_ch_layout,in_sample_fmt,in_sample_rate, 0,NULL); swr_init(swrCtx); //输出的声道个数 int out_nb_channels = av_get_channel_layout_nb_channels(out_ch_layout); //重采样设置参数------------end //JNI------------------begin //HzhPlayer jclass player_class = (*env)-&gt;GetObjectClass(env, jthiz); //AudioTrack对象 jmethodID create_audio_track_mid = (*env)-&gt;GetMethodID(env, player_class, "createAudioTrack", "(II)Landroid/media/AudioTrack;"); jobject audio_track = (*env)-&gt;CallObjectMethod(env, jthiz, create_audio_track_mid,out_sample_rate,out_nb_channels); //调用AudioTrack.play方法 jclass audio_track_class = (*env)-&gt;GetObjectClass(env, audio_track); jmethodID audio_track_play_mid = (*env)-&gt;GetMethodID(env, audio_track_class, "play", "()V"); (*env)-&gt;CallVoidMethod(env,audio_track,audio_track_play_mid); //AudioTrack.write jmethodID audio_track_write_mid = (*env)-&gt;GetMethodID(env, audio_track_class, "write", "([BII)I"); //JNI------------------end //16bit 44100HZ PCM 数据 uint8_t *out_buffer = av_malloc(MAX_AUDIO_FRAME_SIZE); //FILE *fp_pcm = fopen(output_cstr,"wb"); int got_frame = 0, ret,framecount = 0; //不断读取压缩数据 while (av_read_frame(pFormatCtx, packet) &gt;= 0)&#123; //解码音频类型的packet if (packet-&gt;stream_index == audio_stream_idx)&#123; ret = avcodec_decode_audio4(codecCtx, frame, &amp;got_frame, packet); if (ret &lt; 0)&#123; LOGI("%s","解码完成"); &#125; //解码一帧成功 if (got_frame &gt; 0)&#123; LOGI("解码%d帧", ++framecount); swr_convert(swrCtx, &amp;out_buffer,MAX_AUDIO_FRAME_SIZE, (const uint8_t **) frame-&gt;data, frame-&gt;nb_samples); //获取sample的size int out_buffer_size = av_samples_get_buffer_size(NULL, out_nb_channels, frame-&gt;nb_samples, out_sample_fmt, 1); //out_buffer缓冲区数据，转成byte数组 jbyteArray audio_sample_array = (*env)-&gt;NewByteArray(env, out_buffer_size); jbyte *sample_byte = (*env)-&gt;GetByteArrayElements(env, audio_sample_array, NULL); //out_buffer的数据赋值到sample_byte memcpy(sample_byte,out_buffer,out_buffer_size); //同步 (*env)-&gt;ReleaseByteArrayElements(env,audio_sample_array,sample_byte,0); //fwrite(out_buffer,1,out_buffer_size,fp_pcm); //AudioTrack.write PCM数据 (*env)-&gt;CallIntMethod(env,audio_track,audio_track_write_mid, audio_sample_array,0,out_buffer_size); //释放局部引用 (*env)-&gt;DeleteLocalRef(env,audio_sample_array); usleep(1000 * 16); &#125; &#125; av_free_packet(packet); &#125; //fclose(fp_pcm); av_frame_free(&amp;frame); av_free(out_buffer); swr_free(&amp;swrCtx); avcodec_close(codecCtx); avformat_close_input(&amp;pFormatCtx); (*env)-&gt;ReleaseStringUTFChars(env,input_jstr,input_cstr); (*env)-&gt;ReleaseStringUTFChars(env,output_jstr,output_cstr);&#125;]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_ffmpeg</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg视频解码_像素格式转换与native原生绘制]]></title>
    <url>%2F2019%2F09%2F27%2F09_14_ffmpeg%2F</url>
    <content type="text"><![CDATA[CMakeLists.txt123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127# For more information about using CMake with Android Studio, read the# documentation: https://d.android.com/studio/projects/add-native-code.html# Sets the minimum version of CMake required to build the native library.cmake_minimum_required(VERSION 3.4.1)set(my_lib_path $&#123;CMAKE_SOURCE_DIR&#125;/libs/$&#123;ANDROID_ABI&#125;)set(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;/../jniLibs/$&#123;ANDROID_ABI&#125;)include_directories($&#123;CMAKE_SOURCE_DIR&#125;/libs/include/ffmpeg)include_directories($&#123;CMAKE_SOURCE_DIR&#125;/libs/include/libyuv)# Creates and names a library, sets it as either STATIC# or SHARED, and provides the relative paths to its source code.# You can define multiple libraries, and CMake builds them for you.# Gradle automatically packages shared libraries with your APK.add_library( avutil-54 SHARED IMPORTED )set_target_properties( avutil-54 PROPERTIES IMPORTED_LOCATION $&#123;my_lib_path&#125;/libavutil-54.so)add_library( swresample-1 SHARED IMPORTED )set_target_properties( swresample-1 PROPERTIES IMPORTED_LOCATION $&#123;my_lib_path&#125;/libswresample-1.so)add_library( avcodec-56 SHARED IMPORTED )set_target_properties( avcodec-56 PROPERTIES IMPORTED_LOCATION $&#123;my_lib_path&#125;/libavcodec-56.so)add_library( avfilter-5 SHARED IMPORTED )set_target_properties( avfilter-5 PROPERTIES IMPORTED_LOCATION $&#123;my_lib_path&#125;/libavfilter-5.so)add_library( swscale-3 SHARED IMPORTED )set_target_properties( swscale-3 PROPERTIES IMPORTED_LOCATION $&#123;my_lib_path&#125;/libswscale-3.so)add_library( avdevice-56 SHARED IMPORTED)set_target_properties( avdevice-56 PROPERTIES IMPORTED_LOCATION $&#123;my_lib_path&#125;/libavdevice-56.so )add_library( avformat-56 SHARED IMPORTED )set_target_properties( avformat-56 PROPERTIES IMPORTED_LOCATION $&#123;my_lib_path&#125;/libavformat-56.so)add_library( postproc-53 SHARED IMPORTED )set_target_properties( postproc-53 PROPERTIES IMPORTED_LOCATION $&#123;my_lib_path&#125;/libpostproc-53.so)add_library( yuv SHARED IMPORTED )set_target_properties( yuv PROPERTIES IMPORTED_LOCATION $&#123;my_lib_path&#125;/libyuv.so)add_library( # Sets the name of the library. ffmpeg_player # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). src/main/cpp/ffmpeg_player.c )# Searches for a specified prebuilt library and stores the path as a# variable. Because CMake includes system libraries in the search path by# default, you only need to specify the name of the public NDK library# you want to add. CMake verifies that the library exists before# completing its build.find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log )find_library( # Sets the name of the path variable. android-lib # Specifies the name of the NDK library that # you want CMake to locate. android )# Specifies libraries CMake should link to your target library. You# can link multiple libraries, such as libraries you define in this# build script, prebuilt third-party libraries, or system libraries.target_link_libraries( # Specifies the target library. ffmpeg_player avutil-54 swresample-1 avcodec-56 avfilter-5 avdevice-56 swscale-3 avformat-56 postproc-53 yuv # Links the target library to the log library # included in the NDK. $&#123;log-lib&#125; $&#123;android-lib&#125;) HzhPlayer12345678910111213141516public class HzhPlayer &#123; public native void render(String input,Surface surface); static &#123; System.loadLibrary("avutil-54"); System.loadLibrary("swresample-1"); System.loadLibrary("avcodec-56"); System.loadLibrary("avformat-56"); System.loadLibrary("swscale-3"); System.loadLibrary("postproc-53"); System.loadLibrary("avfilter-5"); System.loadLibrary("avdevice-56"); System.loadLibrary("ffmpeg_player"); &#125;&#125; VideoView12345678910111213141516171819202122/** * 视频绘制的“画布” */public class VideoView extends SurfaceView &#123; public VideoView(Context context) &#123; super(context); &#125; public VideoView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public VideoView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; private void init()&#123; //初始化，SurfaceView绘制的像素格式 SurfaceHolder holder = getHolder(); holder.setFormat(PixelFormat.RGBA_8888); &#125;&#125; ffmpeg_decode.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include "com_hzh_ffmpeg_player_VideoUtils.h"#include &lt;android/log.h&gt;#define LOGI(FORMAT,...) __android_log_print(ANDROID_LOG_INFO,"hzh",FORMAT,##__VA_ARGS__)#define LOGE(FORMAT,...) __android_log_print(ANDROID_LOG_ERROR,"hzh",FORMAT,##__VA_ARGS__)//封装格式#include "libavformat/avformat.h"//解码#include "libavcodec/avcodec.h"#include "libswscale/swscale.h"JNIEXPORT void JNICALL Java_com_hzh_ffmpeg_1player_VideoUtils_decode (JNIEnv *env, jclass jcls, jstring input_jstr, jstring output_jstr)&#123; const char* input_cstr = (*env)-&gt;GetStringUTFChars(env,input_jstr,NULL); const char* output_cstr = (*env)-&gt;GetStringUTFChars(env,output_jstr,NULL); //1.注册组件 av_register_all(); //封装格式上下文 AVFormatContext* pFormatCtx = avformat_alloc_context(); //2. if (avformat_open_input(&amp;pFormatCtx,input_cstr,NULL,NULL)!=0)&#123; LOGE("%s","打开输入视频文件失败"); return; &#125; //3.获取视频信息 if (avformat_find_stream_info(pFormatCtx,NULL) &lt; 0)&#123; LOGE("%s","获取视频信息失败"); return; &#125; //视频解码，需要找到视频对应的AVStream所在的索引位置 int video_stream_idx = -1; int i = 0; for (; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123; //根据类型判断，是否是视频流 if (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO)&#123; video_stream_idx = i; break; &#125; &#125; //4.获取视频解码器 AVCodecContext *pCodecCtx = pFormatCtx-&gt;streams[video_stream_idx]-&gt;codec; AVCodec *pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id); if (pCodec == NULL)&#123; LOGE("%s","无法解码"); return; &#125; //5.打开解码器 if (avcodec_open2(pCodecCtx,pCodec,NULL) &lt; 0)&#123; LOGE("%s","解码器无法打开"); return; &#125; //编码数据 AVPacket *packet = av_malloc(sizeof(AVPacket)); //像素数据（解码数据） AVFrame *pFrame = av_frame_alloc(); AVFrame *yuvFrame = av_frame_alloc(); //只有指定了AVFrame的像素格式，画面大小才能真正分配内存 //缓冲区分配内存 uint8_t *out_buffer = av_malloc(avpicture_get_size(AV_PIX_FMT_YUV420P,pCodecCtx-&gt;width,pCodecCtx-&gt;height)); //设置yuvFrame的缓冲区、像素格式 avpicture_fill(yuvFrame, out_buffer, AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height); //输出文件 FILE *fp_yuv = fopen(output_cstr, "wb"); //用于像素格式转换或者缩放 struct SwsContext *sws_ctx = sws_getContext( pCodecCtx-&gt;width,pCodecCtx-&gt;height,pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width,pCodecCtx-&gt;height,AV_PIX_FMT_YUV420P, SWS_BILINEAR,NULL,NULL,NULL); int len,got_frame,framecount = 0; //6.一帧一帧读取压缩的视频数据AVPacket while(av_read_frame(pFormatCtx, packet) &gt;= 0)&#123; //解码AVPacket-&gt;AVFrame if (packet-&gt;stream_index == video_stream_idx)&#123; len = avcodec_decode_video2(pCodecCtx,pFrame,&amp;got_frame,packet); //0代表解码完成(Zero if no frame could be decompressed) //非零，正在解码 if (got_frame)&#123; //frame-&gt;yuvFrame(YUV420P) //转为指定的YUV420P像素帧 sws_scale(sws_ctx, pFrame-&gt;data,pFrame-&gt;linesize, 0,pFrame-&gt;height, yuvFrame-&gt;data,yuvFrame-&gt;linesize); //向YUV文件保存解码之后的帧数据 //AVFrame-&gt;YUV //一个像素包含一个Y int y_size = pCodecCtx-&gt;width * pCodecCtx-&gt;height; fwrite(yuvFrame-&gt;data[0],1,y_size,fp_yuv); fwrite(yuvFrame-&gt;data[1],1,y_size/4,fp_yuv); fwrite(yuvFrame-&gt;data[2],1,y_size/4,fp_yuv); LOGI("解码%d帧",++framecount); &#125; &#125; av_free_packet(packet); &#125; fclose(fp_yuv); av_frame_free(&amp;yuvFrame); av_frame_free(&amp;pFrame); avcodec_close(pCodecCtx); avformat_free_context(pFormatCtx); (*env)-&gt;ReleaseStringUTFChars(env,input_jstr,input_cstr); (*env)-&gt;ReleaseStringUTFChars(env,output_jstr,output_cstr);&#125; video_player.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include "com_hzh_ffmpeg_player_HzhPlayer.h"#include &lt;android/log.h&gt;#include &lt;unistd.h&gt;#include &lt;android/native_window_jni.h&gt;#include &lt;android/native_window.h&gt;//编码#include "libavcodec/avcodec.h"//封装格式处理#include "libavformat/avformat.h"//像素处理#include "libswscale/swscale.h"#ifdef __cplusplusextern "C" &#123;#endif #include "libyuv.h"#ifdef __cplusplus&#125;#endif#define LOGI(FORMAT,...) __android_log_print(ANDROID_LOG_INFO,"hzh",FORMAT,##__VA_ARGS__)#define LOGE(FORMAT,...) __android_log_print(ANDROID_LOG_ERROR,"hzh",FORMAT,##__VA_ARGS__)JNIEXPORT void JNICALL Java_com_hzh_ffmpeg_1player_HzhPlayer_render (JNIEnv *env, jobject jobj, jstring input_jstr, jobject surface)&#123; //需要转码的视频文件(输入的视频文件) const char* input_cstr = (*env)-&gt;GetStringUTFChars(env,input_jstr,NULL); //1.注册所有组件 av_register_all(); //封装格式上下文，统领全局的结构体，保存了视频文件封装格式的相关信息 AVFormatContext *pFormatCtx = avformat_alloc_context(); //2.打开输入视频文件 if (avformat_open_input(&amp;pFormatCtx, input_cstr, NULL, NULL) != 0) &#123; LOGE("%s","无法打开输入视频文件"); return; &#125; //3.获取视频文件信息 if (avformat_find_stream_info(pFormatCtx,NULL) &lt; 0) &#123; LOGE("%s","无法获取视频文件信息"); return; &#125; //获取视频流的索引位置 //遍历所有类型的流（音频流、视频流、字幕流），找到视频流 int video_stream_idx = -1; int i = 0; //number of streams for (; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123; //流的类型 if (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123; video_stream_idx = i; break; &#125; &#125; if (video_stream_idx == -1) &#123; LOGE("%s","找不到视频流\n"); return; &#125; //只有知道视频的编码方式，才能够根据编码方式去找到解码器 //获取视频流中的编解码上下文 AVCodecContext *pCodecCtx = pFormatCtx-&gt;streams[video_stream_idx]-&gt;codec; //4.根据编解码上下文中的编码id查找对应的解码 AVCodec *pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id); //（迅雷看看，找不到解码器，临时下载一个解码器） if (pCodec == NULL) &#123; LOGE("%s","找不到解码器\n"); return; &#125; //5.打开解码器 if (avcodec_open2(pCodecCtx,pCodec,NULL)&lt;0) &#123; LOGE("%s","解码器无法打开\n"); return; &#125; //输出视频信息 LOGI("视频的文件格式：%s",pFormatCtx-&gt;iformat-&gt;name); LOGI("视频时长：%lld", (pFormatCtx-&gt;duration/1000000)); LOGI("视频的宽高：%d,%d",pCodecCtx-&gt;width,pCodecCtx-&gt;height); LOGI("解码器的名称：%s",pCodec-&gt;name); //准备读取 //AVPacket用于存储一帧一帧的压缩数据（H264） //缓冲区，开辟空间 AVPacket *packet = (AVPacket*)av_malloc(sizeof(AVPacket)); //像素数据（解码数据） AVFrame *yuv_frame = av_frame_alloc(); AVFrame *rgb_frame = av_frame_alloc(); //native绘制 //窗体 ANativeWindow* nativeWindow = ANativeWindow_fromSurface(env, surface); //绘制时的缓冲区 ANativeWindow_Buffer outBuffer; int got_frame, len, frame_count = 0; //6.一帧一帧的读取压缩数据 while (av_read_frame(pFormatCtx, packet) &gt;= 0) &#123; //只要视频压缩数据（根据流的索引位置判断） if (packet-&gt;stream_index == video_stream_idx) &#123; //7.解码一帧视频压缩数据，得到视频像素数据 len = avcodec_decode_video2(pCodecCtx, yuv_frame, &amp;got_frame, packet); if (len &lt; 0) &#123; LOGE("%s","解码错误"); return; &#125; //为0说明解码完成，非0正在解码 if (got_frame) &#123; LOGI("解码第%d帧",++frame_count); //lock //设置缓冲区的属性（宽、高、像素格式） ANativeWindow_setBuffersGeometry(nativeWindow, pCodecCtx-&gt;width, pCodecCtx-&gt;height, WINDOW_FORMAT_RGBA_8888); ANativeWindow_lock(nativeWindow,&amp;outBuffer,NULL); //设置rgb_frame的属性（像素格式、宽高）和缓冲区 //rgb_frame缓冲区与outBuffer.bits是同一块内存 avpicture_fill(rgb_frame, outBuffer.bits, PIX_FMT_RGBA, pCodecCtx-&gt;width, pCodecCtx-&gt;height); //YUV-&gt;RGBA_8888 I420ToARGB(yuv_frame-&gt;data[0],yuv_frame-&gt;linesize[0], yuv_frame-&gt;data[2],yuv_frame-&gt;linesize[2], yuv_frame-&gt;data[1],yuv_frame-&gt;linesize[1], rgb_frame-&gt;data[0],rgb_frame-&gt;linesize[0], pCodecCtx-&gt;width,pCodecCtx-&gt;height); //unlock ANativeWindow_unlockAndPost(nativeWindow); usleep(1000 * 16); &#125; &#125; //释放资源 av_free_packet(packet); &#125; ANativeWindow_release(nativeWindow); av_frame_free(&amp;yuv_frame); avcodec_close(pCodecCtx); avformat_free_context(pFormatCtx); (*env)-&gt;ReleaseStringUTFChars(env,input_jstr,input_cstr);&#125; MainActivity调用1234private HzhPlayer player;Surface surface = videoView.getHolder().getSurface();player.render(input, surface); libyuv下载1git clone https://chromium.googlesource.com/external/libyuv]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_ffmpeg</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO流_STL标准模板库]]></title>
    <url>%2F2019%2F09%2F27%2F09_07_C%2B%2B_02%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;fstream&gt;//IO流//文本文件操作/*void main()&#123; char* fname = "c://dest.txt"; //输出流 ofstream fout(fname); //创建失败 if (fout.bad())&#123; return; &#125; fout &lt;&lt; "jack" &lt;&lt; endl; fout &lt;&lt; "rose" &lt;&lt; endl; //关闭 fout.close(); //读取 ifstream fin(fname); if (fin.bad())&#123; return; &#125; char ch; while (fin.get(ch))&#123; //输出 cout &lt;&lt; ch; &#125; fin.close(); system("pause");&#125;*///二进制文件/*void main()&#123; char* src = "c://src.jpg"; char* dest = "c://dest.jpg"; //输入流 ifstream fin(src, ios::binary); //输出流 ofstream fout(dest, ios::binary); if (fin.bad() || fout.bad())&#123; return; &#125; while (!fin.eof())&#123; //读取 char buff[1024] = &#123; 0 &#125;; fin.read(buff, 1024); //写入 fout.write(buff, 1024); &#125; //关闭 fin.close(); fout.close(); system("pause");&#125;*///C++对象的持久化/*class Person&#123;public: Person() &#123; &#125; Person(char * name, int age) &#123; this-&gt;name = name; this-&gt;age = age; &#125; void print() &#123; cout &lt;&lt; name &lt;&lt; "," &lt;&lt; age &lt;&lt; endl; &#125;private: char * name; int age;&#125;;void main()&#123; Person p1("柳岩", 22); Person p2("rose", 18); //输出流 ofstream fout("c://c_obj.data", ios::binary); fout.write((char*)(&amp;p1), sizeof(Person)); //指针能够读取到正确的数据，读取内存区的长度 fout.write((char*)(&amp;p2), sizeof(Person)); fout.close(); //输入流 ifstream fin("c://c_obj.data", ios::binary); Person tmp; fin.read((char*)(&amp;tmp), sizeof(Person)); tmp.print(); fin.read((char*)(&amp;tmp), sizeof(Person)); tmp.print(); system("pause");&#125;*///stl (standard template library)标准模板库//util//c++ 集合-&gt;java 集合/*#include&lt;string&gt;void main()&#123; string s1 = "craig david"; string s2("7 days"); string s3 = s1 + s2; cout &lt;&lt; s3 &lt;&lt; endl; //转c字符串 const char* c_str = s3.c_str(); cout &lt;&lt; c_str &lt;&lt; endl; cout &lt;&lt; s1.at(2) &lt;&lt; endl; system("pause");&#125;*///容器#include&lt;vector&gt;void main()&#123; //动态数组 //不需要使用动态内存分配，就可以使用动态数组 vector&lt;int&gt; v; v.push_back(12); v.push_back(10); v.push_back(5); for (int i = 0; i &lt; v.size(); i++)&#123; cout &lt;&lt; v[i] &lt;&lt; endl; &#125; system("pause");&#125;]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_C++</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_C++</tag>
      </tags>
  </entry>
</search>
