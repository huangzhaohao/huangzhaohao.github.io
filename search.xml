<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[结构体与结构体指针]]></title>
    <url>%2F2018%2F11%2F26%2F08_07_C_01%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#define _CRT_SECURE_NO_WARNINGS#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;Windows.h&gt;//结构体是一种构造数据类型//把不同的数据类型整合起来成为一个自定义的数据类型/*struct Man&#123; //成员 char name[20]; int age; //int(*func)();&#125;;void main()&#123; //初始化结构体的变量 //1. //struct Man m1 = &#123;"Jack",21&#125;; //2. struct Man m1; m1.age = 23; //m1.name = "Rose"; strcpy(m1.name, "rose"); sprintf(m1.name, "Jason"); //类似JavaScript字面量赋值，只能在变量声明时赋值 //m1 = &#123;&#125;; struct Man m2 = m1; printf("%s,%d\n", m1.name, m1.age); getchar();&#125;*///结构体的几种写法/*struct Man&#123; char name[20]; int age;&#125;m1, m2 = &#123;"jack",20&#125;; //m1,m2结构体变量名//typedef int Age;void main()&#123; strcpy(m1.name,"Jack"); m1.age = 10; printf("%s,%d,%s,%d",m1.name,m1.age,m2.name,m2.age); getchar();&#125;*///匿名结构体//控制结构体变量的个数（限量版)，相当于单例/*struct&#123; char name[20]; int age;&#125;m1;*///结构体嵌套/*struct Teacher&#123; char name[20];&#125;;struct Student&#123; char name[20]; int age; struct Teacher t;&#125;;void main()&#123; //字面量的方式 //struct Student s1 = &#123; "jack", 21, &#123;"Jason"&#125; &#125;; struct Student s1; s1.age = 10; strcpy(s1.t.name, "Jason"); system("pause");&#125;*///结构体嵌套2/*struct Student&#123; char name[20]; int age; struct Teacher&#123; char name[20]; &#125; t;&#125;;void main()&#123; struct Student s1; strcpy(s1.t.name, "Jason"); //struct Teacher t2; system("pause");&#125;*///结构体与指针/*struct Man&#123; char name[20]; int age;&#125;;void main()&#123; struct Man m1 = &#123; "jack", 30 &#125;; //结构体指针 struct Man *p = &amp;m1; printf("%s,%d\n", m1.name, m1.age); printf("%s,%d\n",(*p).name,(*p).age); //-&gt;(箭头)是"(*p)."简写形式 printf("%s,%d\n", p-&gt;name, p-&gt;age); system("pause");&#125;*///指针与结构体数组/*struct Man&#123; char name[20]; int age;&#125;;void main()&#123; struct Man mans[] = &#123; &#123; "Jack", 20 &#125;, &#123; "Rose", 19 &#125; &#125;; //遍历结构体数组 //1. struct Man *p = mans; for (; p &lt; mans + 2; p++)&#123; printf("%s,%d\n", p-&gt;name, p-&gt;age); &#125; //2. int i = 0; for (; i &lt; sizeof(mans)/sizeof(struct Man); i++)&#123; printf("%s,%d\n", mans[i].name, mans[i].age); &#125; system("pause");&#125;*///结构体的大小(字节对齐)//int：4个字节，double：8个字节,结构体的大小要能被最大的整除，所以该大小不是12个字节，而是16个字节/*struct Man&#123; int age; double weight;&#125;;void main()&#123; //结构体变量的大小，必须是最宽基本数据类型的整数倍 //提升读取的效率 struct Man m1 = &#123; 20, 89.0 &#125;; printf("%#x,%d\n",&amp;m1,sizeof(m1)); getchar();&#125;*///结构体与动态内存分配/*struct Man&#123; char *name; int age;&#125;;void main()&#123; struct Man *m_p = (struct Man*)malloc(sizeof(struct Man) * 10); struct Man *p = m_p; //赋值 p-&gt;name = "Jack"; p-&gt;age = 20; p++; p-&gt;name = "Rose"; p-&gt;age = 20; struct Man *loop_p = m_p; for (; loop_p &lt; m_p + 2; loop_p++)&#123; printf("%s, %d\n",loop_p-&gt;name,loop_p-&gt;age); &#125; free(m_p); getchar();&#125;*///typedef 类型取别名//1.不同名称代表在干不同的事情typedef int jint;//2.不同情况下，使用不同的别名//#if defined(_cplusplus)//typedef _JNIEnv JNIEnv//typedef _JavaVM JavaVM//3.书写简洁/*struct Man&#123; char name[20]; int age;&#125;;//Age int类型的别名typedef int Age;//Age int类型指针的别名typedef int* Ap;typedef struct Man JavaMan;typedef struct Man* JM;//结构体取别名typedef struct Woman&#123; char name[20]; int age;&#125;;// W, *WP; //W是Woman结构体的别名，WP是Woman结构体指针的别名typedef struct Woman W, *WP;void main()&#123; int i = 5; Ap p = &amp;i; //结构体变量 W w1 = &#123;"Rose",20&#125;; //结构体指针 WP wp1 = &amp;w1; printf("%s, %d\n", w1.name, w1.age); printf("%s, %d\n", wp1-&gt;name, wp1-&gt;age); getchar();&#125;*///结构体函数指针成员/*struct Girl&#123; char *name; int age; //函数指针 void(*sayHi)(char*);&#125;;//Girl结构体类似于Java中的类，name和age类似于属性，sayHi类似于方法void sayHi(char* text)&#123; MessageBox(0,text,"title",0);&#125;void main()&#123; struct Girl g1; g1.name = "Lucy"; g1.age = 18; g1.sayHi = sayHi; g1.sayHi("hello"); getchar();&#125;*/typedef struct Girl&#123; char *name; int age; //函数指针 void(*sayHi)(char*);&#125;Girl;//Girl结构体指针取别名GirlPtypedef Girl *GirlP;void sayHi(char* text)&#123; MessageBoxA(0, text, "title", 0);&#125;//改名void reName(GirlP gp1)&#123; gp1-&gt;name = "Lily";&#125;void main()&#123; Girl g1 = &#123;"Lucy",18,sayHi&#125;; GirlP gp1 = &amp;g1; gp1-&gt;sayHi("Bye"); //传递指针，改名 reName(gp1); printf("%s", gp1-&gt;name); getchar();&#125;]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_C语言</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串]]></title>
    <url>%2F2018%2F11%2F20%2F08_03_C_02%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;Windows.h&gt;//使用字符数组存储字符串/*void main()&#123; //char str[] = &#123; 'c' , 'h' , 'i' , 'n' , 'a' , '\0' &#125;; //char str[6] = &#123; 'c', 'h', 'i', 'n', 'a' &#125;;//多出一个默认为'\0' char str[10] = "china"; //可以修改 str[0] = 's'; printf("%s\n", str); printf("%#x\n", str); getchar();&#125;*///字符指针/*void main()&#123; //内存连续排列 char *str = "how are you?"; //不能修改 //str += 1; //*str = 'y'; //str[0] = 'w'; printf("%s\n", str); printf("%#x\n", str); //使用指针加法，截取字符串 str += 3; while (*str)&#123;//取不到值时*str为0 printf("%c", *str); str++; &#125; getchar();&#125;*///strcat字符串拼接函数//在线API文档：//http://www.kuqin.com/clib/string/strcpy.html/*void main(void)&#123; char dest[50]; char *a = "china"; char *b = " is powerful!"; strcpy(dest, a); strcat(dest, b); printf("%s\n", dest); system("pause");&#125;*///strchr在一个串中查找给定字符的第一个匹配之处/*void main(void)&#123; char *str = "I want go to USA!"; //U元素的指针 //str+3 char* p = strchr(str, 'w'); if (p)&#123; printf("索引位置：%d\n", p - str); &#125; else&#123; printf("没有找到"); &#125; system("pause");&#125;*///strstr 从字符串haystack中寻找needle第一次出现的位置/*void main(void)&#123; char *haystack = "I want go to USA!"; char *needle = "to"; //U元素的指针 char* p = strstr(haystack, needle); if (p)&#123; printf("索引位置：%d\n", p - haystack); &#125; else&#123; printf("没有找到"); &#125; system("pause");&#125;*///strcmp 比较字符串 strcmpi 比较字符串，忽略大小写/*void main(void)&#123; char *str1 = "abc"; char *str2 = "ABC"; //int r = strcmp(str1, str2); int r = _strcmpi(str1, str2); printf("%d\n", r); //str1 &gt; str2 if (r &gt; 0)&#123; printf("str1 大于str2\n"); &#125; else if (r == 0)&#123; printf("str1 等于str2\n"); &#125; //str1 &lt; str2 else if (r &lt; 0)&#123; printf("str1 小于str2\n"); &#125; system("pause");&#125;*///strset 把字符串s中的所有字符都设置成字符c/*void main(void)&#123; char str[] = "internet change the world!"; _strset(str, 'w'); printf("%s\n", str); system("pause");&#125;*///strrev 把字符串s的所有字符的顺序颠倒过来/*void main(void)&#123; char str[] = "internet change the world!"; _strrev(str); printf("%s\n", str); system("pause");&#125;*///atoi 字符串转为int类型//atol()：将字符串转换为长整型值/*void main(void)&#123; char* str = "78"; int r = atoi(str); printf("%d\n", r); system("pause");&#125;*/// 字符串转为double类型/*void main(void)&#123; char* str = "77b8b"; char** p = NULL; //char* p = str + 2; //参数说明：str为要转换的字符串，endstr 为第一个不能转换的字符的指针 double r = strtod(str,p); printf("%lf\n", r); printf("%#x\n", p); system("pause");&#125;*///strupr转换为大写/*void main(void)&#123; char str[] = "CHINA motherland!"; _strupr(str); printf("%s\n", str); system("pause");&#125;*///转换为小写/*void mystrlwr(char str[], int len)&#123; int i = 0; for (; i &lt; len; i++)&#123; //A-Z 字母 a-Z if (str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z')&#123; str[i] = str[i] - 'A' + 'a'; &#125; &#125;&#125;void main(void)&#123; char str[] = "CHINA motherland!"; mystrlwr(str, strlen(str)); printf("%s\n", str); system("pause");&#125;*///练习：删除字符串中指定的字符/*void delchar(char *str, char del)&#123; char *p = str; while (*str != '\0') &#123; if (*str != del) &#123; *p++ = *str; &#125; str++; &#125; *p = '\0';&#125;//删除最后一个字符int main()&#123; char str[] = "vencent ppqq"; delchar(str, 't'); printf("%s\n", str); system("pause");&#125;*///Java String replaceAll//StringBuffer buff.deleteCharAt(buff.length()-1);//删除最后一个字符/*void main(void)&#123; char str[] = "internet,"; str[strlen(str) - 1] = '\0'; printf("%s\n", str); //作业：realloc实现StringBuffer的拼接，而不是一开始开辟一个很大的数组 //结构体StringBuffer system("pause");&#125;*///memcpy 由src所指内存区域复制count个字节到dest所指内存区域/*void main(void)&#123; char src[] = "C,C++,Java"; char dest[20] = &#123; 0 &#125;; //字节 memcpy(dest, src, 5); printf("%s\n", dest); system("pause");&#125;*///memchr 从buf所指内存区域的前count个字节查找字符ch。/*void main(void)&#123; char src[] = "C,C++,Java"; char ch = 'C'; //字节 (分段截取) char* p = memchr(src + 3, ch, 5); if (p)&#123; printf("索引：%d\n", p - src); &#125; else&#123; printf("找不到\n"); &#125; system("pause");&#125;*///memmove 由src所指内存区域复制count个字节到dest所指内存区域。/*void main()&#123; char s[] = "Michael Jackson!"; //截取的效果 memmove(s, s + 8, strlen(s) - 8 - 1); s[strlen(s) - 8] = 0; printf("%s\n", s); getchar();&#125;*///在字符串s1中寻找字符串s2中任何一个字符相匹配的第一个字符的位置，空字符NULL不包括在内void main()&#123; char *s1 = "Welcome To Beijing"; char *s2 = "to"; char *p; p = strpbrk(s1, s2); if (p) printf("%s\n", p); else printf("Not Found!\n"); p = strpbrk(s1, "Da"); if (p) printf("%s", p); else printf("Not Found!"); getchar();&#125;]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_C语言</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态内存分配]]></title>
    <url>%2F2018%2F11%2F20%2F08_03_C_01%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;Windows.h&gt;//动态内存分配/*void main()&#123; //40M //stack overflow错误，栈溢出 //静态内存分配 int a[1024 * 1024 * 10 * sizeof(int)]; //栈内存 //c语言内存分配： //1.栈区(stack) //windows下，栈内存分配2M（确定的常数）,超出了限制，提示stack overflow错误 //自动分配，释放 //2.堆区(heap) //程序员手动分配和释放，操作系统80%内存 //3.全局区或静态区 //4.字符常量区 //5.程序代码区 getchar();&#125;*//*//栈内存void stackFun()&#123; int a[1024]; //栈内存自动释放&#125;//堆内存void heapFun()&#123; //40M内存 //void *任意类型的指针 int* p = malloc(1024 * 1024 * 10 * sizeof(int)); //释放 free(p);&#125;void main()&#123; //在堆内存上，分配40M的内存 while (1)&#123; Sleep(1000); stackFun(); &#125; getchar();&#125;*///创建一个数组，动态指定数组的大小//(在程序运行过程中，可以随意的开辟指定大小的内存以供使用，相当于JAVA中的集合)//静态内存分配，分配内存大小是固定的，问题：1.很容易超出栈内存的最大值 2.为了防止内存不够用会开辟更多的内存，容易浪费内存//动态内存分配，在程序运行过程中，动态指定需要使用的内存大小，手动释放，释放之后这些内存还可以被重新使用/*void main()&#123; //静态内存分配创建数组，数组的大小是固定的 int a[10]; int len; printf("输入数组的长度："); scanf("%d", &amp;len); //开辟内存，内存大小len*4字节 int* p = malloc(len * sizeof(int)); //p,数组的首地址，p就是数组的名称 //给数组元素赋值（使用这一块刚刚开辟出来的内存区域） int i = 0; for (; i &lt; len; i++)&#123; p[i] = rand() % 100; printf("%d,%#x\n", p[i], &amp;p[i]); &#125; //手动释放内存 free(p); getchar();&#125;*///realloc 重新分配内存/*void main()&#123; int len; printf("第一次输入数组的长度："); scanf("%d", &amp;len); //int* p = malloc(len * sizeof(int)); int* p = calloc(len, sizeof(int)); int i = 0; for (; i &lt; len; i++)&#123; p[i] = rand() % 100; printf("%d,%#x\n", p[i], &amp;p[i]); &#125; int addLen; printf("输入数组增加的长度："); scanf("%d", &amp;addLen); //内存不够用，扩大刚刚分配的内存空间 //1.原来内存的指针 2.内存扩大之后的总大小 int* p2 = realloc(p, sizeof(int)* (len + addLen)); if (p2 == NULL)&#123; printf("重新分配失败，能分配的内存不够用了"); &#125; //重新分配内存的两种情况： //缩小，缩小的那一部分数据会丢失 //扩大，（连续的） //1.如果当前内存段后面有需要的内存空间，直接扩展这段内存空间，realloc返回原指针 //2.如果当前内存段后面的空闲字节不够，那么就使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并将原来的数据块释放掉，返回新的内存地址 //3.如果申请失败，返回NULL，原来的指针仍然有效 //重新赋值 i = 0; for (; i &lt; len + addLen;i++)&#123; p2[i] = rand() % 200; printf("%d,%#x\n", p2[i], &amp;p2[i]); &#125; //手动释放内存 if (p2 != NULL)&#123; free(p2); p2 = NULL; &#125; getchar();&#125;*///内存分配的几个注意细节//1.不能多次释放//2.释放完之后，给指针置NULL，标志释放完成//3.内存泄漏(p重新赋值之后，再free,并没有真正释放内存)/*void main()&#123; int len; printf("输入数组的长度："); scanf("%d", &amp;len); int* p = malloc(len * sizeof(int)); int i = 0; for (; i &lt; len; i++)&#123; p[i] = rand() % 100; printf("%d,%#x\n", p[i], &amp;p[i]); &#125; if (p != NULL)&#123; free(p); p = NULL; &#125; getchar();&#125;*/void main()&#123; //40M int* p1 = malloc(1024 * 1024 * 10 * sizeof(int)); free(p1); p1 = NULL; printf("%#x\n", p1); //80M p1 = malloc(1024 * 1024 * 10 * sizeof(int) * 2); free(p1); p1 = NULL; getchar();&#125;]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_C语言</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针类型_空指针_二级指针_指针运算_指针与数组]]></title>
    <url>%2F2018%2F11%2F17%2F08_01_C_01%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include&lt;Windows.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;//指针为什么要有类型？//指针有类型，地址没有类型//地址只是开始的位置，类型读取到什么位置结束/*void main()&#123; int i = 90; //int 类型的指针 int *p = &amp;i; double j = 89.3; //赋值为double类型变量的地址 p = &amp;j; printf("double size:%d\n", sizeof(double)); printf("%#x,%lf\n", p,*p); getchar();&#125;*///2.NULL空指针/*void main()&#123; int i = 9; int *p = NULL; //p = &amp;i; //空指针的默认值为0 printf("%#x\n", p); //访问内存地址0x000000操作系统不允许 //p = 10000; //操作系统不允许访问 printf("%d\n", *p); getchar();&#125;*///3.多级指针(二级指针)//指针保存的是变量的地址，保存的这个变量还可以是一个指针变量//动态内存分配给二维数组/*void main()&#123; int a = 50; //p1上保存的a的地址 int *p1 = &amp;a; //p2上保存的p1的地址 int **p2 = &amp;p1; printf("p1:%#x,p2:%#x\n", p1, p2); **p2 = 90; printf("%d\n", a); getchar();&#125;*///4.指针的运算//指针的运算，一般在数组遍历时才有意义，基于数组在内存中线性排列的方式/*void main()&#123; //数组在内存中连续存储 int ids[] = &#123;78,90,23,65,19&#125;; //数组变量名：ids就是数组的首地址 printf("%#x\n",ids); printf("%#x\n", &amp;ids); printf("%#x\n", &amp;ids[0]); printf("%#x\n", &amp;ids[1]); //指针变量 int *p = ids; printf("%d\n", *p); //指针的加法 p++; //p++向前移动sizeof(数据类型)个字节 printf("%d\n", *p); getchar();&#125;*///通过指针给数组赋值/*void main()&#123; int uids[5]; //高级写法 //int i = 0; //for (; i &lt; 5; i++)&#123; // uids[i] = i; //&#125; //早些版本的写法 int *p = uids; printf("%#x\n", p); int i = 0; for (; p &lt; uids + 5; p++)&#123; *p = i; i++; &#125; getchar();&#125;*///6.函数指针/*int msg(char* msg,char* title)&#123; MessageBox(0,msg,title,0); return 0;&#125;void main()&#123; //msg(); printf("%#x\n", msg); printf("%#x\n", &amp;msg); //函数指针 //函数返回值类型，函数指针的名称，函数的参数列表 int(*fun_p)(char* msg, char* title) = msg; fun_p("消息内容","标题"); getchar();&#125;*/int add(int a, int b)&#123; return a + b;&#125;int minus(int a,int b)&#123; return a - b;&#125;//msg函数需要传递一个函数指针参数//类似于Java中的回调函数/*void msg(int(*func_p)(int a, int b), int m, int n)&#123; printf("执行一段代码...\n"); printf("执行另外一个函数...\n"); int r = func_p(m,n); printf("执行结果:%d\n", r);&#125;void main()&#123; //加法 //int(*func_p)(int a, int b) = add; msg(add, 10, 20); //减法 //int(*func_p)(int a, int b) = minus; msg(minus, 50, 10); getchar();&#125;*///案列：用随机数生成一个数组，写一个函数查找最小的值，并返回最小值的地址，在主函数中打印出来int* getMinPointer(int ids[], int len)&#123; int i = 0; int* p = &amp;ids[0]; for (; i &lt; len;i++)&#123; if (ids[i] &lt; *p)&#123; p = &amp;ids[i]; &#125; &#125; return p;&#125;void main()&#123; int ids[10]; int i = 0; //初始化随机数发生器，设置种子，种子不一样，随机数才不一样 //当前时间作为种子 有符号 int --xx -&gt; +xx srand((unsigned)time(NULL)); for (; i &lt; 10; i++)&#123; ids[i] = rand() % 100; printf("%d\n", ids[i]); &#125; int* p = getMinPointer(ids, sizeof(ids) / sizeof(int)); printf("%#x,%d\n", p, *p); getchar();&#125;]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_C语言</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本数据类型_输入输出_注意事项_指针]]></title>
    <url>%2F2018%2F11%2F16%2F07_31_C_01%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#define _CRT_SECURE_NO_WARNINGS //宏定义//引入头文件//只有函数的声明，编译时去找函数的实现#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;Windows.h&gt;/*void main()&#123; printf("hello world\n"); system("pause");&#125;*///1.基本数据类型//int short long float double char/*int %dshort %dlong %ldfloat %fdouble %lfchar %c%x 十六进制%o 八进制%s 字符串*//*void main()&#123; int i = 1; printf("%d\n", i); float f = 23.3; printf("%f\n", f); //基本数据类型所占的字节数 printf("int占%d字节\n", sizeof(int)); printf("char占%d字节\n", sizeof(char)); printf("float占%d字节\n", sizeof(float)); //循环 int n = 0; for (; n &lt; 10; n++)&#123; printf("%d\n",n); &#125; //等待输入,跟system("pause")差不多 getchar();&#125;*///2.输入输出函数/*void main()&#123; int i; printf("请输入一个整数："); //赋值 scanf("%d", &amp;i); //控制台输入，&amp;取地址符 //打印 printf("i的值为：%d\n", i); system("pause");&#125;*///指针//指针存储的是变量的内存地址//内存地址，系统给数据分配的编号(门牌号)/*void main()&#123; int i = 90; //指针变量，创建一个int类型的指针 int* p = &amp;i; //p的值就是i这个变量的内存地址 printf("%#x\n", p); float f = 89.5; //创建一个float类型的指针 float *fp = &amp;f; printf("%#x\n", fp); system("pause");&#125;*//*void change(int *p)&#123; *p = 300;&#125;//变量名，对内存空间上的一段数据的抽象void main()&#123; int i = 90; //i = 89; //创建一个int类型的指针 int *p = &amp;i; //输出地址 printf("p的地址：%#x\n", &amp;p); printf("i的地址：%#x\n", &amp;i); printf("i的值为：%d\n", i); //间接赋值 //*p = 200; //change(p); change(&amp;i); //int *p = &amp;i; printf("i的值为：%d\n", i); system("pause");&#125;*/void main()&#123; int time = 600; printf("time:%#x\n", &amp;time); while (time &gt; 0)&#123; time--; printf("游戏时间剩余%d秒\n", time); //睡眠 Sleep(1000); &#125; system("pause");&#125; 12345678#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;__declspec(dllexport) void go()&#123; //修改time变量的值 int *p = 0x50fb58; *p = 999999;&#125;]]></content>
      <categories>
        <category>NDK开发</category>
        <category>NDK_C语言</category>
      </categories>
      <tags>
        <tag>NDK开发</tag>
        <tag>NDK_C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
        <category>Hello</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Hello</tag>
      </tags>
  </entry>
</search>
